---
title: "Chart Dev Work"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk[["set"]](echo = FALSE, 
    fig.width = 8,
    fig.height = 6)

# Load Libraries:
library(colorspace)
library(magrittr)
library(grid)
library(gridExtra)
library(tidyverse)
library(bre) # blackstone R package

set.seed(424429) # for reproducibility

##### colors:
breColors <- c("dark_blue" = "#283251",
                "light_grey" = "#eaeaeb",
                "med_grey" = "#cecece",
                "main_grey" = "#c0bfbf")


# light grey to BRE Blue color scale:
pal_bre_grey_blue <- colorRampPalette(c(breColors["light_grey"], breColors["dark_blue"]))
# pal_bre_grey_blue(length(scale_labels))
# 
# white to BRE Blue color scale:
pal_bre_blue <- colorRampPalette(c("white", breColors["dark_blue"]))
# pal_bre_grey_blue(length(scale_labels))

######## Data
items <- dplyr::tibble(
  pre_Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  post_Organization = dplyr::if_else(pre_Organization < 5, pre_Organization + 1, pre_Organization),
  pre_Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  post_Source = dplyr::if_else(pre_Source < 4, pre_Source + 2, pre_Source),
  pre_Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  post_Publish = pre_Publish + 2,
  pre_Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  post_Write = pre_Write + 1,
  pre_Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
  post_Research = pre_Research + 1
)

items_single <- dplyr::tibble(
  Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
)

items_four <- dplyr::tibble(
  pre_Organization = c(1, 2, 3, 4, 4, 4, 3, 2, 1),
  post_Organization = dplyr::if_else(pre_Organization < 4, pre_Organization + 1, pre_Organization),
  pre_Source = c(2, 2, 3, 4, 4, 3, 2, 1, 2),
  post_Source = dplyr::if_else(pre_Source < 4, pre_Source + 2, pre_Source),
  pre_Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  post_Publish = pre_Publish + 2,
  pre_Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  post_Write = pre_Write + 1,
  pre_Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
  post_Research = pre_Research + 1
)


# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_min_ext_named <- c(
  "Minimal" = "1", "Slight" = "2", "Moderate" = "3",
  "Good" = "4", "Extensive" = "5"
)

# levels_min_ext as just the names from levels_min_ext_named:
levels_min_ext <- names(levels_min_ext_named) 

# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_min_good_named <- c(
  "Minimal" = "1", "Slight" = "2", "Moderate" = "3",
  "Good" = "4"
)

# levels_min_ext as just the names from levels_min_ext_named:
levels_min_good <- names(levels_min_good_named) 
# Question labels as a named vector with the naming structure
# like this: c("new label" = "original variable name"):
question_labels <- c(
  "Publish a lot of high quality papers" = "Publish",
  "Write a lot of research papers" = "Write",
  "Research in a lab with faculty" = "Research",
  "Organization of a large research project" = "Organization",
  "Source work for a research paper" = "Source"
)

# Recode the numeric to factor variables using the levels from levels_min_ext and Select the factor variables:
cat_items <- bre::recodeCat(items, levels_min_ext_named) %>% dplyr::select(dplyr::where(is.factor))
cat_items_four <- bre::recodeCat(items_four , levels_min_good_named) %>% dplyr::select(dplyr::where(is.factor))
cat_items_single <- bre::recodeCat(items_single, levels_min_ext_named) %>% dplyr::select(dplyr::where(is.factor))


######## Data: Strongly disagree to Strongly Agree
items_single_div <- dplyr::tibble(
  Organization = c(1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 1),
  Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2, 6, 6, 6, 7, 7,7),
  Publish = c(1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4 , 5, 6, 7, 6),
  Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4, 5,6,7,1,2,3),
  Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4, 5,6,7,1,2,3),
)

items_div <- dplyr::tibble(
  pre_Organization = items_single_div[["Organization"]],
  post_Organization = dplyr::if_else(pre_Organization < 7, pre_Organization + 1, pre_Organization),
  pre_Source = items_single_div[["Source"]],
  post_Source = dplyr::if_else(pre_Source < 5, pre_Source + 2, pre_Source),
  pre_Publish = items_single_div[["Publish"]],
  post_Publish = dplyr::if_else(pre_Publish < 6, pre_Publish + 2, pre_Publish),
  pre_Write = items_single_div[["Write"]],
  post_Write = dplyr::if_else(pre_Write < 7, pre_Write + 1, pre_Write),
  pre_Research = items_single_div[["Research"]],
  post_Research = dplyr::if_else(pre_Research < 7, pre_Research + 1, pre_Research) 
)

# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_dis_agree_named <- c(
  "Strongly Disagree" = "1", "Somewhat Disagree" = "2", "Disagree" = "3",
  "Neither Agree or Disagree" = "4", "Agree" = "5", "Somewhat Agree" = "6", "Strongly Agree" = "7"
)

# levels_min_ext as just the names from levels_min_ext_named:
levels_dis_agree <- names(levels_dis_agree_named) 

# Recode the numeric to factor variables using the levels from levels_min_ext and Select the factor variables:
cat_items_div <- bre::recodeCat(items_div, levels_dis_agree_named) %>% dplyr::select(dplyr::where(is.factor))
cat_items_single_div <- bre::recodeCat(items_single_div, levels_dis_agree_named) %>% dplyr::select(dplyr::where(is.factor))

# for grouped arrow chart:
# add a grouping var to the data set `items`:
items_group <- dplyr::tibble(
   items,
   edu_level = factor(c(
       "grad", "undergrad", "grad", "undergrad", "grad",
       "undergrad", "undergrad", "grad", "undergrad"
  ), levels = c("grad", "undergrad"))
 ) %>% mutate(
            post_Research = dplyr::if_else(pre_Research > 2, pre_Research - 2, pre_Research)
 )
```

### Div bar chart dev:

```{r}

divBarChart_new <- function(df, scale_labels, fill_colors = "seq", pre_post = FALSE, overall_n = FALSE, percent_label = TRUE,
                            question_labels = NULL, question_order= FALSE, width = NULL, font_family = "Arial", font_size = 10) {
    # Load all fonts:
    extrafont::loadfonts("all", quiet = TRUE)

    # Set . to NULL to stop message when using dot notation in mutate:
    . <- NULL

    # Start of data manipulation: ----
    # Make sure the all vars in df are factors with scale_labels as their levels:
    new_df <- {{ df }} %>% dplyr::mutate(dplyr::across(tidyselect::everything(), ~ factor(., levels = scale_labels)))

    if (isTRUE(pre_post)) {
        # If pre_post is TRUE, set up new_df with dataVizCleaning():
        new_df <- dataVizCleaning(df = new_df, pre_post = TRUE, scale_labels = scale_labels, na_remove = TRUE)

        # Get total n for each question, grouped by question and timing:
        totals_new_df <- new_df %>%
          dplyr::group_by(.data[["question"]], .data[["timing"]]) %>%
          dplyr::summarize(total = sum(.data[["n_answers"]]), .groups = "keep") %>%
          dplyr::ungroup() %>%
          dplyr::group_by(.data[["question"]]) %>%
          dplyr::distinct(.data[["question"]], .data[["total"]]) %>%
          dplyr::ungroup()
        # End of if pre_post == TRUE
    } else if (isFALSE(pre_post)) {
          # If pre_post is FALSE, set up new_df with dataVizCleaning():
          new_df <- dataVizCleaning(df = new_df, pre_post = FALSE, scale_labels = scale_labels, na_remove = TRUE)

        # Get total n for each question, grouped by question:
        totals_new_df <- new_df %>%
          dplyr::group_by(.data[["question"]]) %>%
          dplyr::summarize(total = sum(.data[["n_answers"]]), .groups = "keep") %>%
          dplyr::ungroup()
    } # End of if pre_post == FALSE

    # Set up a new question order if not supplied by the user after finding the most positive valenced items for post
    # if pre_post is TRUE, otherwise use questions if pre_post is FALSE (top levels depending on total response levels):
    if (isFALSE(question_order)) {
        if (isTRUE(pre_post)) {
            new_question_order <- questionOrder(df = new_df, pre_post = TRUE)
        } else if (isFALSE(pre_post)) {
            new_question_order <- questionOrder(df = new_df, pre_post = FALSE)
        }
        # change the factor levels of question to be ordered by the question_order:
        new_df <- new_df %>% dplyr::mutate(question = forcats::fct_relevel(.data[["question"]], new_question_order))
    } else {
        # If question_order == TRUE,set up the levels for question using the user supplied order = question_labels:
        new_df <- new_df %>% dplyr::mutate(question = factor(.data[["question"]], levels = question_labels))
    }

    # If the user supplies a named vector for questions labels:
    if (!is.null(question_labels)) {
        names(question_labels) <- names(question_labels) %>%
            stringr::str_wrap(., width = 15) %>%
            gsub("\n", "<br>", .)
        new_df <- new_df %>%
            dplyr::mutate(question = forcats::fct_recode(.data[["question"]], !!!question_labels))
    }

    # 5 colors for chart- If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
    
    # Named vector created by new color palette named by the scale_labels:
    new_fill_colors_named <- new_fill_colors # new color palette as values
    names(new_fill_colors_named) <- stringr::str_wrap(scale_labels, width = 10) # str wrapped for legend
    
    # Named vector created by new color palette named by the scale_labels:
    new_fill_colors_named_unwrapped <- new_fill_colors # new color palette as values
    names(new_fill_colors_named_unwrapped) <- scale_labels # pass to scale_fill_manual()
    
    # Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
    label_colors_named <- labelColorMaker(new_fill_colors, names = names(new_fill_colors_named))
    # create a new col `label_color` using the named vector `label_colors_named` to map the text color to the variable response
    new_df <- new_df %>% dplyr::mutate(., label_color = label_colors_named[new_df[["response"]]]) 

    # Calculate the width and height of legend keys using `names(new_fill_colors_named)` (i.e. str_wrap scale_labels)
    # Legend key width = maximum label strwidth: PASS TO guide_legend keywidth
    key_width <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strwidth, units = "inches")) * 0.9, "in")
    # Create a minimum default of key_width being at least 0.7 inches:
    key_width <- dplyr::if_else(as.numeric(key_width) > 0.7, as.numeric(key_width), 0.7) %>% grid::unit(., "in")
    # Legend key height = maximum label strheight: PASS TO guide_legend keyheight
    key_height <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strheight, units = "inches")) * 0.95, "in")
    # Create a minimum default of key_height being at least 0.35 inches:
    key_height <- dplyr::if_else(as.numeric(key_height) > 0.35, as.numeric(key_height), 0.35) %>% grid::unit(., "in")
    
    #Caluculate the split for the diverging point from the `response` variable:
    # response_levels <- levels(pull(new_df, .data[["response"]])) # gets the levels of response from data
    split_level <-  ceiling(length(scale_labels)/2) # Split the response var so that more levels on the bottom
    top_num_level <- length(scale_labels) - split_level # Get the top number of levels
    top_levels <- tail(scale_labels, top_num_level) # Get the top scale levels from `scale_labels`
    bottom_levels <- rev(head(scale_labels, split_level)) # Get the the bottom scale levels and rev them
    new_div_levels <- c(bottom_levels, top_levels) # get the new order of the response variable
    
    
    # Set up data so that the response in top_levels are positive percent_answers and the rest at the bottom
    # are negative percent_answers:
    if (isTRUE(pre_post)) { # If pre_post: group_by "question" and "timing"
        new_df <- new_df %>%
            dplyr::group_by(.data[["question"]], .data[["timing"]])
    } else if (isFALSE(pre_post)) { # if not group_by only "question":
        new_df <- new_df %>%
            dplyr::group_by(.data[["question"]])
    }
    new_df <- new_df  %>%
        dplyr::mutate(
          percent_answers = dplyr::case_when(
            .data[["response"]] %in% top_levels ~ percent_answers, # when `response` is in the top levels of scale_labels pos otherwise neg
            .data[["response"]] %in% bottom_levels ~ -percent_answers
          ),
          # Sets response levels to: 3,2,1,4,5 = this is so LHS of chart is reversed to create the diverging bars:
          response = forcats::fct_relevel(.data[["response"]], new_div_levels) # sets new order based on reversing the bottom levels
        ) %>%
        dplyr::ungroup() %>% 
        dplyr::arrange(.data[["response"]])

    # Set default width for geom_col() bars if not supplied by user:
    if (is.null(width)) {
        width <- dplyr::if_else(dplyr::n_distinct(new_df[["question"]]) < 4, 0.7, 0.9)
    }

    if (isTRUE(overall_n)) {
        # Return N_df that will be an overall n for all the items, only if all totals_new_df$total are equal to each other: ----
        N_df <- NULL
        if (length(unique(totals_new_df[["total"]])) == 1) {
          # Get overall n if it is the same for each item:
          N_df <- totals_new_df %>%
            dplyr::summarize(N = mean(.data[["total"]])) %>%
            tibble::deframe()
        }
        # Error messages if N_df is null, not filled by last if statement above:
        if (is.null(N_df)) {
          stop("Error: Can not use `overall_n` for this function, responses for variables are not of equal length. Use argument: `overall_n = FALSE`.")
        }
    } else if (isFALSE(overall_n)) { # Otherwise, if overall_n == FALSE, return a stacked_bar_chart with n for each question appended to the question label:
        # Change the label of the variable "question" by adding n of each to the end of the character string:
        labels_n_questions <- paste0(totals_new_df[["question"]], " ", "(*n* = ", totals_new_df[["total"]], ")")

        # Set factor labels for question to labels:
        new_df <- new_df %>%
          dplyr::mutate(question = factor(.data[["question"]], levels = levels(.data[["question"]]), labels = labels_n_questions))
    }

    # Start of chart creation: --------
    # Set labels to percent or n_answers:
    if (isTRUE(percent_label)) { label_gg <- new_df[["percent_answers_label"]] } else { label_gg <- new_df[["n_answers"]]  }
    
    # Set up initial aes for div bar chart: 
    diverging_bar_chart <- new_df %>%
        ggplot2::ggplot(ggplot2::aes(
          x = .data[["percent_answers"]], fill = .data[["response"]], label = {{ label_gg }}, group = .data[["question"]]
        )) 
    if (isTRUE(pre_post)) { # If pre_post: set y to "timing", if not set to "question":
    diverging_bar_chart <- diverging_bar_chart + 
        ggplot2::aes(y = forcats::fct_rev(.data[["timing"]])
        )
    } else if (isFALSE(pre_post)) {
        diverging_bar_chart <- diverging_bar_chart +
        ggplot2::aes(y = forcats::fct_rev(.data[["question"]])
        )
    }
    # Set up geom_col for bars, text for labels and use scale_color_identity() to color the text of labels:
    diverging_bar_chart <-  diverging_bar_chart +
        ggplot2::geom_col(width = width, position = ggplot2::position_stack(reverse = TRUE), 
                          color = "black", key_glyph = draw_key_cust) + # sets up custom legend as text boxes with fill colors
        ggplot2::geom_text(ggplot2::aes(color = .data[["label_color"]]),
                           position = ggplot2::position_stack(vjust = .5, reverse = TRUE),
                           family = font_family, size = font_size, size.unit = "pt"
        ) +
        ggplot2::scale_color_identity()
    # If pre_post: add facet_wrap:
    if (isTRUE(pre_post)) {
        diverging_bar_chart <-  diverging_bar_chart + ggplot2::facet_wrap(~ .data[["question"]], ncol = 1, strip.position = "left")
    }
        diverging_bar_chart <-  diverging_bar_chart +
        ggplot2::scale_fill_manual(values = new_fill_colors_named_unwrapped, labels = NULL) + # turn off labels in legend
        ggplot2::guides(fill = ggplot2::guide_legend(
            nrow = 1, keywidth = key_width, keyheight = key_height, # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
            override.aes = list(
                color = label_colors_named, # manually sets the color of the legend text to white or black
                label = names(new_fill_colors_named), # manually sets the legend labels to wrapped scale_labels
                fill = new_fill_colors_named # manually resets the fill order of response to the original inside 'new_fill_colors_named'
                                ) 
        )) +
        addBarChartTheme(font_size = font_size, font_family = font_family) 
    # Add additional theme options for pre_post chart:
    if (isTRUE(pre_post)) {
        diverging_bar_chart <- diverging_bar_chart + addBarChartPrePostTheme(font_size = font_size, font_family = font_family)
    }

    # Set tag to N_df if overall_n_gg == TRUE
    if (isTRUE(overall_n)) {
        diverging_bar_chart <- diverging_bar_chart + addPlotTag(n = N_df, font_size = font_size, font_family = font_family)
    }
    
    return(diverging_bar_chart)
}



```

```{r}
# Test divBarChart_new single
stackedBarChart(
    df = cat_items_single, pre_post = F, scale_labels = levels_min_ext, overall_n = T,
    question_labels = NULL, percent_label = TRUE, width = NULL, fill_colors = "seq"
    )

divBarChart_new(
    df = cat_items_single, pre_post = F, scale_labels = levels_min_ext, overall_n = T,
    question_labels = NULL, percent_label = TRUE, width = NULL, fill_colors = "seq"
    )

```


```{r}
# Test divBarChart_new single
stackedBarChart(
    df = cat_items, pre_post = T, scale_labels = levels_min_ext, overall_n = T,
    question_labels = NULL, percent_label = TRUE, width = NULL, fill_colors = "seq"
    )

divBarChart_new(
    df = cat_items, pre_post = T, scale_labels = levels_min_ext, overall_n = T,
    question_labels = NULL, percent_label = TRUE, width = NULL, fill_colors = "div"
    )


```



```{r}
# WORKS!!!
df <- cat_items
scale_labels <- levels_min_ext
# df <- cat_items_div
# scale_labels <- levels_dis_agree
question_order <- F
width <- NULL
overall_n <- F
percent_label <- F
fill_colors  <- "seq"
question_labels <- NULL
#     c(
#   "Publish a lot of high quality papers" = "Publish",
#   "Write a lot of research papers" = "Write",
#   "Research in a lab with faculty" = "Research",
#   "Organization of a large research project" = "Organization",
#   "Source work for a research paper" = "Source"
# )


    # Create a font family character var so that it is easy to change, could also be a new arg:
    font_family <- c("Arial")
    font_size <- 10
    # Set . to NULL to stop message when using dot notation in mutate:
    . <- NULL

    # Make sure the all vars in df are factors with scale_labels as their levels:
    new_df <- {{ df }} %>% dplyr::mutate(dplyr::across(tidyselect::everything(), ~ factor(., levels = scale_labels)))

    # # Changes scale_labels to tibble pulls out index and saves that as a vector, gets number of levels from scale_labels:
    # number_levels <- scale_labels %>%
    #   tibble::enframe() %>%
    #   dplyr::select("name") %>%
    #   tibble::deframe()
    # 
    # If pre_post is TRUE, set up new_df with dataVizCleaning():
    new_df <- dataVizCleaning(df = new_df, pre_post = TRUE, scale_labels = scale_labels, na_remove = TRUE) 
    
    # Set up the question order, either calculated by the function questionOrder() or given by user as the order of `question_labels`
    if (isFALSE(question_order)) {
        new_question_order <- questionOrder(df = new_df, pre_post = TRUE)
        # change the factor levels of question to be ordered by the question_order:
        new_df <- new_df %>% dplyr::mutate(question = forcats::fct_relevel(.data[["question"]], new_question_order))
    } else {
        # If question_order == TRUE,set up the levels for question using the user supplied order = question_labels:
        new_df <- new_df %>% dplyr::mutate(question = factor(.data[["question"]], levels = question_labels))
    }

    # If the user supplies a named vector for questions labels:
    if (!is.null(question_labels)) {
        names(question_labels) <- names(question_labels) %>%
            stringr::str_wrap(., width = 15) %>%
            gsub("\n", "<br>", .)
        new_df <- new_df %>%
            dplyr::mutate(question = forcats::fct_recode(.data[["question"]], !!!question_labels))
    }
    
    # var_order <- new_df %>% dplyr::filter(., .data$timing == "Post") %>% select(c("question","response","n_answers")) %>% 
    #         tidyr::complete(.data$question, .data$response) %>%
    #         tidyr::pivot_wider(names_from = "response", values_from = "n_answers") %>%
    #         dplyr::group_by(.data$question) %>% rev() %>%
    #         dplyr::arrange(dplyr::across(-c("question"), dplyr::desc)) %>%
    #         dplyr::select("question") %>%
    #         unique() %>%
    #         tibble::deframe()
    
    # # 5 colors for chart:
      # fill_colors <- seqFillColors(n_colors = length(number_levels))
      # If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
    
    # Named vector created by new color palette named by the scale_labels:
    new_fill_colors_named <- new_fill_colors # new color palette as values
    names(new_fill_colors_named) <- stringr::str_wrap(scale_labels, width = 10) # str wrapped for legend
    
    # Named vector created by new color palette named by the scale_labels:
    new_fill_colors_named_unwrapped <- new_fill_colors # new color palette as values
    names(new_fill_colors_named_unwrapped) <- scale_labels # pass to scale_fill_manual()
    
    # Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
    label_colors_named <- labelColorMaker(new_fill_colors, names = names(new_fill_colors_named))
    # create a new col `label_color` using the named vector `label_colors_named` to map the text color to the variable response
    new_df <- new_df %>% dplyr::mutate(., label_color = label_colors_named[new_df[["response"]]]) 

    # Calculate the width and height of legend keys using `names(new_fill_colors_named)` (i.e. str_wrap scale_labels)
    # Legend key width = maximum label strwidth: PASS TO guide_legend keywidth
    key_width <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strwidth, units = "inches")) * 0.9, "in")
    # Create a minimum default of key_width being at least 0.7 inches:
    key_width <- dplyr::if_else(as.numeric(key_width) > 0.7, as.numeric(key_width), 0.7) %>% grid::unit(., "in")
    # Legend key height = maximum label strheight: PASS TO guide_legend keyheight
    key_height <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strheight, units = "inches")) * 0.95, "in")
    # Create a minimum default of key_height being at least 0.35 inches:
    key_height <- dplyr::if_else(as.numeric(key_height) > 0.35, as.numeric(key_height), 0.35) %>% grid::unit(., "in")
    
    #Caluculate the split for the diverging point from the `response` variable:
    # response_levels <- levels(pull(new_df, .data[["response"]])) # gets the levels of response from data
    split_level <-  ceiling(length(scale_labels)/2) # Split the response var so that more levels on the bottom
    top_num_level <- length(scale_labels) - split_level # Get the top number of levels
    top_levels <- tail(scale_labels, top_num_level) # Get the top scale levels from `scale_labels`
    bottom_levels <- rev(head(scale_labels, split_level)) # Get the the bottom scale levels and rev them
    new_div_levels <- c(bottom_levels, top_levels) # get the new order of the response variable
    
    
    # Set up data so that the response in top_levels are positive percent_answers and the rest at the bottom
    # are negative percent_answers:
    new_df <- new_df %>%
        dplyr::group_by(.data[["question"]], .data[["timing"]]) %>%
        dplyr::mutate(
          percent_answers = dplyr::case_when(
            .data[["response"]] %in% top_levels ~ percent_answers, # when `response` is in the top levels of scale_labels pos otherwise neg
            .data[["response"]] %in% bottom_levels ~ -percent_answers
          ),
          # Sets response levels to: 3,2,1,4,5 = this is so LHS of chart is reversed to create the diverging bars:
          response = forcats::fct_relevel(.data[["response"]], new_div_levels), # sets new order based on reversing the bottom levels
          pos_valence_post = dplyr::case_when(
            .data[["response"]] %in% top_levels & .data[["timing"]] == "Post" ~ percent_answers,
            TRUE ~ 0
          )
        ) %>%
        dplyr::ungroup() %>% 
        dplyr::arrange(.data[["response"]])

    
    
    # Set default width for geom_col() bars if not supplied by user:
    if (is.null(width)) {
        width <- dplyr::if_else(dplyr::n_distinct(new_df[["question"]]) < 4, 0.7, 0.9)
    }
    
    # Get total n for each question, grouped by question and timing:
    totals_new_df <- new_df %>%
      dplyr::group_by(.data[["question"]], .data[["timing"]]) %>%
      dplyr::summarize(total = sum(.data[["n_answers"]]), .groups = "keep") %>%
      dplyr::ungroup() %>%
      dplyr::group_by(.data[["question"]]) %>%
      dplyr::distinct(.data[["question"]], .data[["total"]]) %>%
      dplyr::ungroup()
    
    if (isTRUE(overall_n)) {
        # Return N_df that will be an overall n for all the items, only if all totals_new_df$total are equal to each other: ----
        N_df <- NULL
        if (length(unique(totals_new_df[["total"]])) == 1) {
          # Get overall n if it is the same for each item:
          N_df <- totals_new_df %>%
            dplyr::summarize(N = mean(.data[["total"]])) %>%
            tibble::deframe()
        }
        # Error messages if N_df is null, not filled by last if statement above:
        if (is.null(N_df)) {
          stop("Error: Can not use `overall_n` for this function, responses for variables are not of equal length. Use argument: `overall_n = FALSE`.")
        }
    } else if (isFALSE(overall_n)) { # Otherwise, if overall_n == FALSE, return a stacked_bar_chart with n for each question appended to the question label:
        # Change the label of the variable "question" by adding n of each to the end of the character string:
        labels_n_questions <- paste0(totals_new_df[["question"]], " ", "(*n* = ", totals_new_df[["total"]], ")")

        # Set factor labels for question to labels:
        new_df <- new_df %>%
          dplyr::mutate(question = factor(.data[["question"]], levels = levels(.data[["question"]]), labels = labels_n_questions))
    }

    # Set labels to percent or n_answers:
    if (isTRUE(percent_label)) {
        label_gg <- new_df[["percent_answers_label"]]
    } else {
        label_gg <- new_df[["n_answers"]]
    }

    diverging_bar_chart <- new_df %>%
        ggplot2::ggplot(ggplot2::aes(
          x = .data[["percent_answers"]], y = forcats::fct_rev(.data[["timing"]]), fill = .data[["response"]],
          label = {{ label_gg }}, group = .data[["question"]]
        )) +
        ggplot2::geom_col(width = width, position = ggplot2::position_stack(reverse = TRUE), 
                          color = "black", key_glyph = draw_key_cust) + # sets up custom legend as text boxes with fill colors
        ggplot2::geom_text(ggplot2::aes(color = .data[["label_color"]]),
                           position = ggplot2::position_stack(vjust = .5, reverse = TRUE),
                           family = font_family, size = font_size, size.unit = "pt"
        ) +
        ggplot2::scale_color_identity() +
        ggplot2::facet_wrap(~question, ncol = 1, strip.position = "left") +
        ggplot2::scale_fill_manual(values = new_fill_colors_named_unwrapped, labels = NULL) + # turn off labels in legend
        ggplot2::guides(fill = ggplot2::guide_legend(
            nrow = 1, keywidth = key_width, keyheight = key_height, # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
            override.aes = list(
                color = label_colors_named, # manually sets the color of the legend text to white or black
                label = names(new_fill_colors_named), # manually sets the legend labels to wrapped scale_labels
                fill = new_fill_colors_named # manually resets the fill order of response to the original inside 'new_fill_colors_named'
                                ) 
        )) +
        addBarChartTheme(font_size = font_size, font_family = font_family) + 
        addBarChartPrePostTheme(font_size = font_size, font_family = font_family)
    # + 
    #     addPlotTag(n = N_df, font_size = font_size, font_family = font_family)

    
diverging_bar_chart
```

```{r}
# taken from SO here: https://stackoverflow.com/questions/51201852/faceted-horizontal-divergent-stacked-bar-plot-including-negative-values-using-dp
library(tidyverse)
#
# summarize groups and save counts in variable quality_cnt
#
  diamonds_cnt <- diamonds %>%
    mutate(quality = fct_recode(cut, "Very_Poor" = "Fair", "Poor" = "Good",
                                "Neutral" = "Very Good", "Good" = "Premium", "Excellent" = "Ideal")) %>%
    select(color, clarity, quality) %>%
    group_by(color, clarity, quality) %>% summarize(quality_cnt = n())

# make function to plot counts    

  plot_ratings <- function(survey, rated_item, rating_cnt, rating, rating_cat, facet = "wrap") {
#
#  Input:   
#         rated_item  =  unquoted variable name of rated items
#         rating = unquoted variable name of ratings for each rated_items; 
#                  variable should be a factor ordered from lowest to highest 
#         rating_cnt = unquoted variable name of counts or frequencies for each rated_item 
#         rated_cat = unquoted variable name of categories of rated items
#         facet  = "grid" for all panels on one row or 
#                   "wrap" to spread panels across multiple rows
#
#  make arguments quosures
#
    rated_item <- enquo(rated_item)
    rating_cnt <- enquo(rating_cnt)  
    rating <- enquo(rating)
    rating_cat <- enquo(rating_cat)
#
# If number of rating levels is odd, find middle rating
#
  rating_levels <- levels(pull(survey, !!rating))
  mid_level <-  ceiling(length(rating_levels)/2)
  mid_rating <- ifelse(length(rating_levels)%%2 == 1, rating_levels[mid_level], NA_character_)  
#
# make local variabels for use with aes
# plot positive and negative columns separately
#
  survey <- survey %>% mutate( rating_plt = !!rating, rating_cnt_plt = !!rating_cnt)

  sp <- ggplot(survey, aes_(x = rated_item,  fill = rating)) + 
        geom_col(data = filter(survey, !!rating %in% tail(rating_levels, mid_level)),
                 aes( y = ifelse(rating_plt == mid_rating, .5*rating_cnt_plt, rating_cnt_plt)),
                 position = position_stack(reverse = TRUE )) +
        geom_col(data = filter(survey, !!rating %in% head(rating_levels, mid_level)),
                 aes( y = ifelse(rating_plt == mid_rating, -.5*rating_cnt_plt, -rating_cnt_plt)),
                 position = "stack") +
        labs(y = rating_cnt) +
        scale_fill_brewer(palette = "RdYlGn", direction = -1) +
        coord_flip() +
        switch(facet,
               grid = facet_grid( facets=rating_cat, scales = "free_x"),
               wrap = facet_wrap( facets=rating_cat, scales = "free_x"))
  plot(sp)
  } 
#
#  Use function to make charts
#
  plot_ratings(diamonds_cnt,  rated_item = color, rating_cnt = quality_cnt, 
               rating = quality, rating_cat = clarity, facet = "wrap")
```


```{r}
# First attempt at trying to get div bars:
df <- cat_items
scale_labels <- levels_min_ext
question_order <- FALSE
width <- NULL
overall_n <- TRUE
percent_label <- TRUE
fill_colors  <- "seq"

    # Create a font family character var so that it is easy to change, could also be a new arg:
    font_family <- c("Arial")
    font_size <- 10
    # Set . to NULL to stop message when using dot notation in mutate:
    . <- NULL

    # Make sure the all vars in df are factors with scale_labels as their levels:
    new_df <- {{ df }} %>% dplyr::mutate(dplyr::across(tidyselect::everything(), ~ factor(., levels = scale_labels)))

    # Changes scale_labels to tibble pulls out index and saves that as a vector, gets number of levels from scale_labels:
    number_levels <- scale_labels %>%
      tibble::enframe() %>%
      dplyr::select("name") %>%
      tibble::deframe()
    
    # If pre_post is TRUE, set up new_df with dataVizCleaning():
    new_df <- dataVizCleaning(df = new_df, pre_post = T, scale_labels = scale_labels, na_remove = TRUE)
    
  response_levels <- levels(pull(new_df, .data[["response"]])) # gets the levels of response from data
  split_level <-  ceiling(length(response_levels)/2)
  top_num_level <- length(scale_labels) - split_level
  top_levels <- tail(scale_labels, top_num_level)
  bottom_levels <- rev(head(scale_labels, mid_level)) # reversed bottom levels
  new_div_levels <- c(bottom_levels, top_levels)
  # mid_rating <- ifelse(length(scale_labels) %% 2 == 1, scale_labels[mid_level], NA_character_)  
    # .data[["percent_answers"]], y = forcats::fct_rev(.data[["timing"]]), fill = .data[["response"]],
    #       label = {{ label_gg }}, group = .data[["question"]]
    new_df %>%
        dplyr::group_by(.data$question, .data$timing) %>%
        dplyr::mutate(
          percent_answers = dplyr::case_when(
            .data$response %in% top_levels ~ percent_answers, # when in the top levels of scale_labels pos otherwise neg
            TRUE ~ -percent_answers
          ),
          # Sets response levels to: 3,2,1,4,5 = this is so LHS of chart is reversed to create the diverging bars:
          response = forcats::fct_relevel(.data$response, new_div_levels), # sets new order based on reversing the bottom levels
          pos_valence_post = dplyr::case_when(
            .data$response %in% top_levels & .data$timing == "Post" ~ percent_answers,
            TRUE ~ 0
          )
        ) %>%
        dplyr::ungroup() %>% 
        dplyr::arrange(.data$response)
    

```

### Setting up custom colors for grouped arrow chart:

```{r}
# create a labeled list of colors
# qualColors <- c(
#   `orange`         = "#E69F00",   # 1
#   `sky blue`       = "#56B4E9",   # 2
#   `bluish green`   = "#009E73",   # 3 
#   `magenta`        = "#CC79A7",   # 4
#   `vermillion`     = "#D55E00",   # 5
#   `blue`           = "#0072B2",   # 6
#   `dark green`     = "#117733",   # 7
#   `viridis purple` = "#440154FF", # 8
#   `dark grey`      = "#999999",   # 9
#   `bre blue`       = "#283251",   # 11
#   `yellow green`   = "#999933"    # 12
#   )
# 
# swatchplot(qualColors)
# # rcartocolor::carto_pal(12, "Safe")
# # "#88CCEE" "#CC6677" "#DDCC77" "#117733" "#332288" "#AA4499" "#44AA99" "#999933" "#882255" "#661100" "#6699CC" "#888888"
# # grDevices::palette.colors(palette = "Okabe-Ito")
# # "#000000" "#E69F00" "#56B4E9" "#009E73" "#F0E442" "#0072B2" "#D55E00" "#CC79A7" "#999999"
# # wrap that list in a callable function
# customCols <- function(pal = qualColors, cols = NULL) {
#     # Gather all color names or vector positions into a new character vector:
#     if (is.null(cols)) { # if nothing passed, return full palette:
#         return(pal) 
#     } else {# Otherwise, return a new palette by selection:
#         return(pal[cols])
#     }
# }
# customCols(cols = c("sky blue", "bluish green", "magenta", "vermillion"))
# customCols(cols = c(1:14))
# 
# qualFillColors <- function(n_colors, rev_colors = FALSE) {
#     if (n_colors > length(qualColors)) {
#         warning("This palette can handle a maximum of ", length(qualColors), " values.",
#                 "You have supplied ", n_colors, ", colors will be recycled to reach this number of values.")
#     } else if (n_colors < 0) {
#         stop("`n_colors` must be a non-negative integer.")
#     }
#     # Uses rep() to recycle the color values so the returned color code vector is length of n_colors 
#     # and has no NA's.
#     new_pal <- rep(qualColors, len = n_colors)
#     if (isTRUE(rev_colors)) {
#         # new_pal <- rev(customCols(cols = c(1:n_colors))) # reversed qualColors palette
#         new_pal <- rev(new_pal) # reversed qualColors palette
#     }
#     
#     return(new_pal)
#     
# }
# 
# # rep(qualColors, len = 30)
# qualFillColors(3, rev_colors = T) 
```

```{r}
# df = items_group
# group = "edu_level"
# group_levels = c("grad", "undergrad")
# 
# # append `overall` to group_levels
# group_levels <- c("overall", group_levels)
# #  Start of data manipulation: ----
#     # Set up a df for the original groups separate average:
#     arrow_df_group <- {{ df }} %>%
#       dplyr::group_by(dplyr::across(dplyr::all_of( {{group}} ))) %>%
#       tidyr::pivot_longer(-{{group}}, names_to = "question", values_to = "response") %>%
#       dplyr::mutate( {{group}} := factor( .data[[group]] )) %>%
#       tidyr::separate(.data$question, into = c("timing", "question"), sep = "_") %>%
#       dplyr::group_by(dplyr::across(dplyr::all_of( {{group}} )), .data$question, .data$timing) %>%
#       dplyr::mutate(timing = factor(.data$timing, levels = c("pre", "post"))) %>%
#       dplyr::summarize(score_avg = mean(.data$response, na.rm = TRUE), .groups = "keep") %>%
#       dplyr::ungroup()
#     arrow_df_group
#     # Set up a df for an overall average
#     arrow_df_all <- {{ df }} %>%
#       dplyr::select(!dplyr::all_of({{group}})) %>% # drop the group var
#       tidyr::pivot_longer(tidyselect::everything(), names_to = "question", values_to = "response") %>%
#       tidyr::separate(.data$question, into = c("timing", "question"), sep = "_") %>%
#       dplyr::group_by(.data$question, .data$timing) %>%
#       dplyr::mutate(timing = factor(.data$timing, levels = c("pre", "post"))) %>%
#       dplyr::summarize(score_avg = mean(.data$response, na.rm = TRUE), .groups = "keep") %>%
#       dplyr::ungroup() %>%
#       dplyr::mutate({{group}} := "overall")
#     arrow_df_all
#     # Full join the data by groups and overall, and then Rev the factor order of "group":
#     arrow_df <- dplyr::full_join(arrow_df_group, arrow_df_all, by = dplyr::join_by( {{group}}, "question", "timing", "score_avg")) %>%
#       dplyr::group_by(dplyr::across(dplyr::all_of( {{group}} )), .data$question, .data$timing) %>%
#       dplyr::mutate(
#         {{group}} := factor(.data[[group]], levels = group_levels) # recode factor levels to group by using `group_levels`
#       ) %>%
#       dplyr::ungroup() %>% 
#       tidyr::pivot_wider( # pivot wider to add a difference in `score_avg` column
#         id_cols = tidyselect::everything(),
#         names_from = timing, 
#         values_from = score_avg,
#         names_glue = "{timing}_score_avg"
#       ) %>% 
#       dplyr::mutate(diff_score_avg = .data$post_score_avg - .data$pre_score_avg) %>% 
#       tidyr::pivot_longer(pre_score_avg:post_score_avg,
#                           names_to = c("timing", ".value"), 
#                           names_pattern = "([A-Za-z]+)_(.*)" # puts prefix of timing and then "score_avg" as the value
#                           )
#    pre_diff_score_avg <- arrow_df %>% dplyr::filter(timing == "post") %>% select(diff_score_avg) %>% deframe() 
#    nudge_x_pre <- dplyr::if_else(pre_diff_score_avg > 0, 0.2, -0.2)

```


```{r}
new_cols <- c(qualFillColors(2))
bre::arrowChartGroup(df = items_group, group = "edu_level", group_levels = c("grad", "undergrad"), scale_labels = levels_min_ext, 
                     group_colors = new_cols, overall_n = T, question_labels = NULL, question_order = FALSE)

```

### Arrow charts without a grouping variable:

#### - With arrows in Blackstone dark blue "#283251" as the default, users can also specify qualatative colors.

```{r}
bre::arrowChart(df = items, scale_labels = levels_min_ext, 
           overall_n = T, question_labels = question_labels, question_order = TRUE)

```

### Testing SB Chart:

```{r}
# Test new sb chart function on sequential color pal:
stackedBarChart(
   df = cat_items_single, pre_post = F, scale_labels = levels_min_ext, overall_n = T,
   question_labels = NULL, percent_label = TRUE, width = NULL, fill_colors = "seq"
 )

# new_fill_colors <- seqFillColors(length(levels_min_ext))
# # Named vector created by new color palette named by the scale_labels:
# new_fill_colors_named <- new_fill_colors # new color palette as values
# names(new_fill_colors_named) <- stringr::str_wrap(levels_min_ext, width = 10) # names as str_wrap scale_labels
# 
# # Calculate the width and height of legend keys using `names(new_fill_colors_named)` (i.e. str_wrap scale_labels)
# # Legend key width = maximum label strwidth: PASS TO guide_legend keywidth
# key_width <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strwidth, units = "inches")) * 0.9, "in")
# # Create a minimum default of key_width being at least 0.7 inches:
# key_width <- if_else(as.numeric(key_width) > 0.7, as.numeric(key_width), 0.7) %>% grid::unit(., "in")
# # Legend key height = maximum label strheight: PASS TO guide_legend keyheight
# key_height <- grid::unit(max(sapply(names(new_fill_colors_named), graphics::strheight, units = "inches")) * 0.95, "in")
# # Create a minimum default of key_height being at least 0.35 inches:
# key_height <- if_else(as.numeric(key_height) > 0.35, as.numeric(key_height), 0.35) %>% grid::unit(., "in")

```

```{r}
# Test new sb chart function on diverging color pal:
stackedBarChart(
   df = cat_items_div, pre_post = T, scale_labels = levels_dis_agree, overall_n = T,
   question_labels = question_labels, percent_label = TRUE, width = NULL, fill_colors = "div"
 )


```


```{r}
# Function dev for gg_helpers.R file:

# Helper function to Add a Plot Tag, pass the total n, font size and family:
addPlotTag <- function(n, font_size, font_family) {
    list(
        ggplot2::labs(tag = paste0("(*n* = ", n , ")")),
        ggplot2::theme(plot.tag = ggtext::element_markdown(color = "black", size = font_size, family = font_family),
                       plot.tag.location = "panel", # places tag within panel
                       # plot.tag.position = "topleft"
                       plot.tag.position = c(-0.035, 1.04) # manually positions the tag using coordinates
                       )
    )
}

# addBarChartLegendTheme: sets the fill legend, and all theming for sb chart and div chart: args = font_size, font_family:
addBarChartLegendTheme <- function(font_size, font_family) {
    list(
        # ggplot2::guides(fill = ggplot2::guide_legend(nrow = 1
        #                                                  # override.aes = list(label = "  ", # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
        #                                                  #                     size = 4.5 # sets the size of legend key along with the two spaces in the previous line 
        #                                                  #                     )
        #                                                  )
            # ),
            ggplot2::theme_void(base_size = font_size, base_family = font_family),
            ggplot2::theme(legend.position = "top",
                           legend.direction = "horizontal",
                           # legend.key = element_rect(color = NA, fill = NA),
                           # legend.key.size = unit(0, "cm"),
                           legend.text.position = "right",
                           legend.text = ggplot2::element_text(angle = 0, hjust = 0, vjust = 0.55,
                                                               family = font_family
                                                               # size = rel(0.8)
                                                              ),
                           legend.box.spacing = unit(0, "cm"),
                           legend.ticks.length = rel(0),
                           legend.title = ggplot2::element_blank(),
                           axis.text = ggplot2::element_text(angle = 0, hjust = 1, vjust = 0.5,
                                                             family = font_family
                           ),
                           axis.text.x = ggplot2::element_blank(),
                           axis.text.y = ggtext::element_markdown( # Controls the 'question' if pre_post is F, or 'timing' if Pre post labels
                               angle = 0, hjust = 1, halign = 1, color = "black",
                               margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
                           ),
                           plot.margin = ggplot2::margin(t = 30, r = 5, b = 30, l = 5, unit = "pt"),
                           panel.spacing = grid::unit(0, "cm")
            )
    )
    
}

# addBarChartPrePostTheme: sets the fill legend, and all theming for sb chart and div chart: args = font_size, font_family:
addBarChartPrePostTheme <- function(font_size, font_family) {
        ggplot2::theme(strip.placement = "outside",
                       strip.switch.pad.wrap = grid::unit(0, "cm"),
                       strip.text.y.left = ggtext::element_markdown( # Controls the question text on left- facet
                           angle = 0, hjust = 1, color = "black", family = font_family, size = font_size,
                           margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
                       ),
                       axis.text.y = ggtext::element_markdown( size = rel(0.8) # Controls the 'timing' Pre post labels
                       )
                    )
    
}

```


### Update `bre::stackedBarChart()`

```{r}
# Start by processing the data using `bre::stackedBarChart()`:
clean_items_div <- dataVizCleaning(df = cat_items_div, scale_labels = levels_dis_agree, pre_post = T, na_remove = TRUE)

# Pull in all code from `stackBar_ggplot.R`:
# stackedBar_ggplot <- function(df_gg, x_gg , y_gg, fill_gg, group_gg, label_gg, label_color_gg, scale_labels_gg, width_gg, fill_colors_gg,
#                                   overall_n_gg, N_df_gg, pre_post = FALSE) {
# Set up arg inputs:                                 
df_gg = clean_items_div
x_gg = clean_items_div[["percent_answers"]]
# y_gg = clean_items_div[["question"]] # single
y_gg = clean_items_div[["timing"]] # pre_post
fill_gg = clean_items_div[["response"]]
group_gg = clean_items_div[["question"]]
scale_labels = levels_dis_agree
scale_labels_gg = scale_labels
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }

# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors` to map the text color to the variable response
clean_items_div <- clean_items_div %>% dplyr::mutate(., label_color = label_colors[clean_items_div[["response"]]])

label_gg = clean_items_div[["percent_answers_label"]]
label_color_gg = clean_items_div[["label_color"]]
width_gg = NULL
fill_colors_gg = new_fill_colors
overall_n_gg = T
# Get overall n if it is the same for each item:
totals_new_df <- clean_items_div %>%
        dplyr::group_by(.data$question) %>%
        dplyr::summarize(total = sum(.data$n_answers), .groups = "keep") %>%
        dplyr::ungroup()
# Get overall n if it is the same for each item:
        N_df <- totals_new_df %>%
          dplyr::summarize(N = mean(.data$total)) %>%
          tibble::deframe()
N_df_gg = N_df
pre_post = T

    # Load all fonts:
    extrafont::loadfonts("all", quiet = TRUE)

    # # Set . to NULL to stop message when using dot notation in mutate:
    # . <- NULL

    # Create a font family character var so that it is easy to change, could also be a new arg:
    font_family <- c("Arial")

    font_size <- 10

    stacked_bar_chart_gg <- {{df_gg}} %>%
        ggplot2::ggplot(ggplot2::aes(
            x = {{x_gg}}, y = forcats::fct_rev({{y_gg}}), group = {{group_gg}})) +
        ggplot2::geom_col(ggplot2::aes(fill = {{fill_gg}}), position = "fill", color = "black", width = {{width_gg}},
                          ) + # key_glyph = ggplot2::draw_key_label
        ggplot2::geom_text(ggplot2::aes(label = {{label_gg}}, color = {{label_color_gg}}), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = (font_size - 2), size.unit = "pt"
        ) +
        ggplot2::scale_color_identity()
    if (isTRUE(pre_post)) {
        stacked_bar_chart_gg <-  stacked_bar_chart_gg + ggplot2::facet_wrap(dplyr::vars({{ group_gg }}), ncol = 1, strip.position = "left")
    }
        stacked_bar_chart_gg <-  stacked_bar_chart_gg +
            ggplot2::scale_fill_manual(values = {{fill_colors_gg}}, drop = FALSE
                                       # labels = NULL,
                                       # guide = guide_legend(nrow = 1, override.aes = list(size = 2, shape = 21)
                                                            # )

            ) +
        addBarChartLegendTheme(font_size = font_size, font_family = font_family) + # function from `gg_helpers.R`
        ggplot2::guides(fill = NULL,
                        # fill = ggplot2::guide_legend(nrow = 1,
                        #           override.aes = list(label = stringr::str_wrap({{scale_labels_gg}}, width = 8), # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                        #           size = 2 # sets the size of legend key along with the two spaces in the previous line
                        #                                                      )
                        #                                  )
                        shape = ggplot2::guide_legend(nrow = 1,
                                  override.aes = list(label = stringr::str_wrap({{scale_labels_gg}}, width = 8), # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                                  size = 2 # sets the size of legend key along with the two spaces in the previous line
                                                                             )
                                                         )
                        ) +
      ggplot2::theme(legend.key.size = unit(1, "cm"),
                     legend.key.width = unit(1, "cm"), 
                     legend.key.height = unit(1, "cm")
        )

    if (isTRUE(pre_post)) {
        stacked_bar_chart_gg <- stacked_bar_chart_gg + addBarChartPrePostTheme(font_size = font_size, font_family = font_family) 
            # ggplot2::theme(strip.placement = "outside",
            #                strip.switch.pad.wrap = grid::unit(0, "cm"),
            #                strip.text.y.left = ggtext::element_markdown( # Controls the question text on left- facet
            #                    angle = 0, hjust = 1, color = "black", family = font_family, size = font_size,
            #                    margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
            #                ),
            #                axis.text.y = ggtext::element_markdown( size = rel(0.8) # Controls the 'timing' Pre post labels
            #                )
            # )
    }

    # Set tag to N_df if overall_n_gg == TRUE
    if (isTRUE(overall_n_gg)) {
        stacked_bar_chart_gg <- stacked_bar_chart_gg + addPlotTag(n = N_df_gg, font_size = font_size, font_family = font_family)
        # addPlotTag() Replaces code below: 
        # stacked_bar_chart_gg <- stacked_bar_chart_gg + ggplot2::labs(tag = paste0("(*n* = ",  N_df_gg , ")")) +
        #                                                ggplot2::theme(plot.tag = ggtext::element_markdown(color = "black", size = font_size, family = font_family),
        #                                                               plot.tag.location = "panel", # places tag within panel
        #                                                               # plot.tag.position = "topleft"
        #                                                               plot.tag.position = c(-0.035, 1.04) # manually positions the tag using coordinates
        #                                                               )
    } else {
        # stacked_bar_chart_gg <- stacked_bar_chart_gg + ggplot2::labs(title = NULL, x = NULL, tag = NULL)
    }
stacked_bar_chart_gg

```



```{r}
# Start by processing the data using `bre::stackedBarChart()`:
clean_items_single_div <- dataVizCleaning(df = cat_items_single_div, scale_labels = levels_dis_agree, pre_post = F, na_remove = TRUE)
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors` to map the text color to the variable response
clean_items_single_div <- clean_items_single_div %>% dplyr::mutate(., label_color = label_colors[clean_items_single_div[["response"]]])

```

```{r}
#  `new_fill_colors` as a named vector combined with `scale_labels`, where the names are the labels and values are the colors from `new_fill_colors`:
new_fill_colors_named <- new_fill_colors
names(new_fill_colors_named) <- stringr::str_wrap(scale_labels, width = 8)
# function to build all grobs:
# map(.x = seq_along(new_fill_colors_named), \(.x)
# list(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[.x]), x = (0 + (.x/10)), y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
#      textGrob(label = names(new_fill_colors_named)[.x], x = (0 + (.x/10)), y = 1, hjust = 0, gp = gp)
#      )
# )
grid::grid.newpage()
## These *do* nothing but produce a "gpar" object:
gp <- gpar(col = "black", fontsize = 10, fontfamily = "Arial")
vp <- viewport(width = .8, height = .4)
g <- gTree(children = gList(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[1]),x = 0, y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
                            textGrob(label = names(new_fill_colors_named)[1], x = 0.03, y = 1, hjust = 0, gp = gp),
                            rectGrob(gp = gpar(col = new_fill_colors_named[2]),x = 0.3, y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm"))
                            ), gp = gp, vp = vp)
grid.draw(g)
## example with multiple values for a parameter
pushViewport(viewport())
popViewport()

```

```{r}
grid.newpage()
gp <- gpar(col = "black", fontsize = 10, fontfamily = "Arial")
vp <- viewport(width = .8, height = .4)
grob_list <- map(.x = seq_along(new_fill_colors_named), \(.x)
                    gList(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[.x]), x = (0 + (.x/7.5)), y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
                          textGrob(label = names(new_fill_colors_named)[.x], x = (0.03 + (.x/7.5)), y = 1, hjust = 0, check.overlap = TRUE, gp = gp)
                          )
                    )
g <- grobTree(children = do.call(grid::gList, grob_list), gp = gp, vp = vp)

# gridExtra::grid.arrange(grobs = grob_list)
# g <- gTree(children = grob_list[[7]], gp = gp, vp = vp)
grid.draw(g)
## example with multiple values for a parameter
pushViewport(viewport())
popViewport()

# is.grob(g)
```



```{r}
## Data:
  n <- 10
  x <- stats::runif(n) ; y1 <- stats::runif(n) ; y2 <- stats::runif(n)
  ## Construct the grobs :
  plot <- gTree(children=gList(rectGrob(),
                  pointsGrob(x, y1, pch=21, gp=gpar(col=2, fill=2)),
                  pointsGrob(x, y2, pch=22, gp=gpar(col=3, fill=3)),
                  xaxisGrob(),
                  yaxisGrob()))
  legd <- grid::legendGrob(names(new_fill_colors_named), nrow = 1, pch = 22, # pch 22 is a filled square
                     hgap = grid::unit(0.2, "cm"), # horz spacing btw legends
                     gp = grid::gpar(col = "black", fontsize = 10, fontfamily = "Arial",
                                     fill = new_fill_colors_named)) # gp fill is the color to fill 
  gg <- packGrob(packGrob(frameGrob(), plot),
                 legd, height=unit(1,"null"), side="top")

  ## Now draw it on a new device page:
  grid.newpage()
  pushViewport(viewport(width=0.8, height=0.8))
  grid.draw(gg)
```

### Rounded edges Rectangle legend 

```{r}
library(ggplot2)
library(gtable)
library(grid)
library(dplyr)
library(forcats)

# Your starting data and plot code
stacked_bar_chart_gg <- {{df_gg}} %>%
  ggplot(ggplot2::aes(
    x = {{x_gg}}, y = forcats::fct_rev({{y_gg}}), group = {{group_gg}}, fill = {{fill_gg}}
  )) +
  geom_col(position = "fill", color = "black", width = {{width_gg}}, key_glyph = draw_key_label) + # , key_glyph = draw_key_rect
   ggplot2::geom_text(ggplot2::aes(label = {{label_gg}}, color = {{label_color_gg}}), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = font_size, size.unit = "pt"
        ) +
  scale_color_identity() +
  scale_fill_manual(
    breaks = {{scale_labels_gg}}, values = {{fill_colors_gg}}, drop = FALSE,
    labels = str_wrap({{scale_labels_gg}}, width = 8)
  ) +
  guides(
    fill = guide_legend(
      nrow = 1,
      override.aes = list(label = "  ", # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                          size = 5 # sets the size of legend key along with the two spaces in the previous line 
                          )
    )
  ) +
  theme_void(base_family = font_family, base_size = font_size) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal",
    legend.text.position = "right",
    legend.text = element_text(
      angle = 0, hjust = 0, vjust = 0.5,
      family = font_family, size = rel(0.8)
    ),
    legend.title = element_blank(),
    axis.text = element_text(
      angle = 0, hjust = 1, vjust = 0.5,
      family = font_family
    ),
    axis.text.x = element_blank(),
    axis.text.y = ggtext::element_markdown(
      angle = 0, hjust = 1, halign = 1, color = "black",
      margin = margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
    ),
    plot.margin = margin(t = 30, r = 5, b = 30, l = 5, unit = "pt"),
    panel.spacing = unit(0, "cm")
  )

stacked_bar_chart_gg

# Extract the ggplot grob
# g <- ggplotGrob(stacked_bar_chart_gg)
# grid::grid.draw(g) 
# # Adjust legend key sizes
# g$grobs <- lapply(g$grobs, function(x) {
#   if(x$name == "gtable[guide-box]") {
#     x$grobs[[1]]$grobs[[1]]$heights <- unit(rep(0.01, length(x$grobs[[1]]$grobs[[1]]$heights)), "cm")
#     x$grobs[[1]]$grobs[[1]]$widths <- unit(rep(2, length(x$grobs[[1]]$grobs[[1]]$widths)), "cm")
#   }
#   return(x)
# })
# 
# 
# ggpubr::as_ggplot(g)

```

### SB Chart with custom legend that are sizable rectangles:

```{r}
legendGrobCustom <-
    function(labels, nrow, ncol, byrow=FALSE,
	     do.lines = has.lty || has.lwd, lines.first=TRUE,
	     hgap=unit(1, "lines"), vgap=unit(1, "lines"),
	     default.units="lines",
	     pch, sym_size = unit(1, "char"), 
	     gp =gpar(), vp=NULL)
{
    ## Type checking on arguments; labels: character, symbol or expression:
    labels <- as.graphicsAnnot(labels)
    labels <- if(is.character(labels)) as.list(labels) else as.expression(labels)
    nkeys <- if(is.call(labels)) 1 else length(labels)
    if(nkeys == 0) return(nullGrob(vp=vp))
    if (!is.unit(hgap))
	hgap <- unit(hgap, default.units)
    if (length(hgap) != 1) stop("'hgap' must be single unit")
    if (!is.unit(vgap))
	vgap <- unit(vgap, default.units)
    if (length(vgap) != 1) stop("'vgap' must be single unit")
    ## nrow, ncol
    miss.nrow <- missing(nrow)
    miss.ncol <- missing(ncol)
    if(miss.nrow && miss.ncol) {ncol <- 1; nrow <- nkeys} # defaults to 1-column legend
    else if( miss.nrow && !miss.ncol) nrow <- ceiling(nkeys / ncol)
    else if(!miss.nrow &&  miss.ncol) ncol <- ceiling(nkeys / nrow)
    if(nrow < 1) stop("'nrow' must be >= 1")
    if(ncol < 1) stop("'ncol' must be >= 1")
    if(nrow * ncol < nkeys)
        stop("nrow * ncol < #{legend labels}")
    ## pch, gp
    if(has.pch <- !missing(pch) && length(pch) > 0) pch <- rep_len(pch, nkeys)
    if(doGP <- length(nmgp <- names(gp)) > 0) {
	if(has.lty  <-  "lty" %in% nmgp) gp$lty  <- rep_len(gp$lty, nkeys)
	if(has.lwd  <-  "lwd" %in% nmgp) gp$lwd  <- rep_len(gp$lwd, nkeys)
	if(has.col  <-  "col" %in% nmgp) gp$col  <- rep_len(gp$col,  nkeys)
	if(has.fill <- "fill" %in% nmgp) gp$fill <- rep_len(gp$fill, nkeys)
    } else {
	gpi <- gp
	if(missing(do.lines)) do.lines <- FALSE
    }

    ## main
    u0 <- unit(0, "npc")
    u1 <- unit(1, "char")
    ord <- if(lines.first) 1:2 else 2:1
    fg <- frameGrob(vp = vp)	  # set up basic frame grob (for packing)
    for (i in seq_len(nkeys)) {
	if(doGP) {
	    gpi <- gp
	    if(has.lty)	 gpi$lty <- gp$lty[i]
	    if(has.lwd)	 gpi$lwd <- gp$lwd[i]
	    if(has.col)	 gpi$col <- gp$col[i]
	    if(has.fill) gpi$fill <- gp$fill[i]
	}
	if(byrow) {
	    ci <- 1+ (i-1) %%  ncol
	    ri <- 1+ (i-1) %/% ncol
	} else {
	    ci <- 1+ (i-1) %/% nrow
	    ri <- 1+ (i-1) %%  nrow
	}
	## borders; unit.c creates a 4-vector of borders (bottom, left, top, right)
	vg <- if(ri != nrow) vgap else u0
	symbol.border <- unit.c(vg, u0, u0, 0.5 * hgap)
	text.border   <- unit.c(vg, u0, u0, if(ci != ncol) hgap else u0)

	## points/lines grob:
	plGrob <- if(has.pch && do.lines)
	    gTree(children = gList(linesGrob(c(sym_size:1, sym_size:1 + 0.5), 0.5, gp=gpi),
		  pointsGrob(0.5, 0.5, default.units="npc", pch=pch[i], gp=gpi, size = sym_size))[ord])
	else if(has.pch) pointsGrob(0.5, 0.5, default.units="npc", pch=pch[i], gp=gpi, size = sym_size)
	else if(do.lines) linesGrob(c(sym_size:1, sym_size:1 + 0.5), 0.5, gp=gpi)
	else nullGrob() # should not happen...
	fg <- packGrob(fg, plGrob,
		       col = 2*ci-1, row = ri, border = symbol.border,
		       width = u1, height = u1, force.width = TRUE)
	## text grob: add the labels
	gpi. <- gpi
	gpi.$col <- "black" # maybe needs its own 'gp' in the long run (?)
	fg <- packGrob(fg, textGrob(labels[[i]], x = 0, y = 0.5,
				    just = c("left", "centre"), gp=gpi.),
		       col = 2*ci, row = ri, border = text.border)
    }
    fg
}

```

```{r}
font_family <- "Arial"
font_size <- 10


new <- clean_items_single_div %>%
        ggplot2::ggplot(ggplot2::aes(
            x = percent_answers, y = forcats::fct_rev(question), group = question)) +
        ggplot2::geom_col(ggplot2::aes(fill = response), position = "fill", color = "black", show.legend = FALSE # turn off legend
                          ) + # key_glyph = ggplot2::draw_key_label
        ggplot2::geom_text(ggplot2::aes(label = percent_answers_label, color = label_color), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = font_size, size.unit = "pt", 
        ) +
    ggplot2::scale_color_identity() +
    ggplot2::scale_fill_manual(values = new_fill_colors, labels = ~ stringr::str_wrap(., width = 8)) +
    ggplot2::guides(custom = ggplot2::guide_custom(grob = legendGrobCustom(names(new_fill_colors_named), # using scale_labels and one row or ncol= 1,
                                                                           nrow = 1, # using scale_labels and one row
                                                                           # do.lines = TRUE,
                                                                           pch = 22, # pch 22 is a filled square
                                                                           sym_size = grid::unit(0.65, "cm"), # new size par for sizing pch symbol 
                                                                           hgap = grid::unit(0.3, "cm"), # horz spacing btw legends
                                                                           gp = grid::gpar(col = "black", fontsize = (font_size - 1), fontfamily = font_family,
                                                                                           lineheight = 0.9,
                                                                                           fill = new_fill_colors),# gp fill is the color to fill
                                                                           )
                                                   )
                    ) +
    ggplot2::theme(legend.position = "top",
                   legend.box.spacing = grid::unit(0, "cm"),
                   axis.ticks = ggplot2::element_blank(),
                   axis.title = ggplot2::element_blank(),
                   axis.text = ggplot2::element_text(angle = 0, hjust = 1, vjust = 0.5,
                                                             family = font_family
                           ),
                   axis.text.x.bottom = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.text.y = ggtext::element_markdown( # Controls the 'question' if pre_post is F, or 'timing' if Pre post labels
                       angle = 0, hjust = 1, halign = 1, color = "black",
                       margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
                   ),
                   plot.background = ggplot2::element_blank(),
                   panel.background = ggplot2::element_blank(),
                   legend.background = ggplot2::element_blank()
                   )

new  


```

### Example custom draw_key_* function:

```{r}
dat <- data.frame(x = seq(1,100,by=2), y = seq(1,300,by=3))

df <- data.frame(class = c("very high", "high", "medium", "low", "very low"),
            lwr = c(90, 75, 35, 15, 0),
            upr = c(100, 90, 75, 35, 15))


# Color palette
pal <- scales::viridis_pal(option = "viridis")(5)
names(pal) <- c("very high", "high", "medium", "low", "very low")

# Legend key labels
key_label <- df |>
  mutate(key_label = case_when(
    upr == 100 ~ paste(">", lwr),
    lwr == 0 ~ paste("<", upr),
    TRUE ~ paste(lwr, upr, sep = "-")
  )) |>
  select(class, key_label) |>
  tibble::deframe()

# Legend key width = maximum label * 1.10 to add some padding
width <- unit(max(sapply(key_label, strwidth, units = "inches")) * 1.10, "in")

# Custom key glyph
draw_key_cust <- function(data, params, size) {
  data_text <- data
  data_text$label <- key_label[names(pal)[match(data$fill, pal)]]
  data_text[c("fill")] <- NULL
  data_text$colour <- "black"
  data_text$alpha <- 1
  data_text$size <- 11 / .pt

  grid::grobTree(
    draw_key_rect(data, list()),
    draw_key_text(data_text, list())
  )
}

ggplot(dat) +
  geom_rect(data = df, aes(xmin = lwr, xmax = upr, ymin = -Inf, ymax = Inf, fill = class), alpha = 0.4, key_glyph = draw_key_cust) +
  geom_point(aes(x, y)) +
  scale_fill_manual("Classes", values = pal, limits = c("very high", "high", "medium", "low", "very low")) +
  guides(fill = guide_legend(keywidth = width, keyheight = unit(.3, "in"))) + # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
  theme_bw() + 
  ggplot2::theme(legend.position = "top")
```


```{r}
scale_labels = levels_dis_agree
# Start by processing the data using `bre::stackedBarChart()`:
clean_items_single_div <- dataVizCleaning(df = cat_items_single_div, scale_labels = levels_dis_agree, pre_post = F, na_remove = TRUE)
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors_named <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors_named` to map the text color to the variable response
clean_items_single_div <- clean_items_single_div %>% dplyr::mutate(., label_color = label_colors_named[clean_items_single_div[["response"]]])

# Color palette named by the scale_labels:
new_fill_colors_named <- new_fill_colors # palette as values
names(new_fill_colors_named) <- str_wrap(scale_labels, width = 10) # names as str_wrap scale_labels

# Legend key width = maximum label strwidth: PASS TO guide_legend keywidth
key_width <- unit(max(sapply(names(new_fill_colors_named), strwidth, units = "inches")) * 0.9, "in")
# Legend key height = maximum label strheight: PASS TO guide_legend keyheight
key_height <- unit(max(sapply(names(new_fill_colors_named), strheight, units = "inches")) * 0.95, "in")

# # Custom draw_key_rect, adds black outline box
# draw_key_rect_cust <- function(data, params, size) {
#   grid::rectGrob(gp = grid::gpar(
#     col = "black", # adds black outline box to each key
#     fill = scales::alpha(data$fill %||% data$colour %||% "grey20", data$alpha),
#     lty = data$linetype %||% 1
#   ))
# }
# # Custom draw_key_text, adds just and lineheight:
# draw_key_text_cust <- function(data, params, size) {
#   if (is.null(data$label)) data$label <- "a"
#   grid::textGrob(data$label, 0.5, 0.5,
#             hjust = 0.5, # horz center justified text
#             vjust = 0.5, # vert center justified text
#             rot = data$angle %||% 0,
#             gp = grid::gpar(
#               col = scales::alpha(data$colour %||% data$fill %||% "black", data$alpha),
#               fontfamily = "Arial", # data$family %||% "",
#               fontface = data$fontface %||% 1,
#               fontsize = 10, # (data$size %||% 3.88) * .pt,
#               lineheight = 0.9
#             )
#         )
# }
# 
# # Custom key glyph
# draw_key_cust <- function(data, params, size) {
#   data_text <- data
#   # data_text$label <- names(new_fill_colors_named)[match(data$fill, new_fill_colors_named)] # match the scale_labels to the new pal in new_fill_colors_named
#   # data_text[c("fill")] <- NULL
#   data_text$alpha <- 1
#   # data_text$size <- 8/.pt
# 
#   grid::grobTree(
#     draw_key_rect_cust(data, list()),
#     draw_key_text_cust(data_text, list())
#   )
# }

# Custom draw_key_rect, adds black outline box
# draw_key_rect_cust <- function(data, params, size) {
#   grid::rectGrob(gp = grid::gpar(
#     col = "black", # adds black outline box to each key
#     fill = scales::alpha(data$fill %||% data$colour %||% "grey20", data$alpha),
#     lty = data$linetype %||% 1
#   ))
# }
# # Custom draw_key_text, adds just and lineheight:
# draw_key_text_cust <- function(data, params, size) {
#   if (is.null(data$label)) data$label <- "a"
#   grid::textGrob(data$label, 0.5, 0.5,
#             hjust = 0.5, # horz center justified text
#             vjust = 0.5, # vert center justified text
#             rot = data$angle %||% 0,
#             gp = grid::gpar(
#               col = scales::alpha(data$colour %||% data$fill %||% "black", data$alpha),
#               fontfamily = "Arial", # data$family %||% "",
#               fontface = data$fontface %||% 1,
#               fontsize = 10, # (data$size %||% 3.88) * .pt,
#               lineheight = 0.9
#             )
#         )
# }

# Custom key glyph that will draw the legend as filled rect boxes colored by fill and text labels that will 
# be the labels of the fill aes, set in guide_legend(override.aes)
draw_key_cust <- function(data, params, size) {
  grid::grobTree(
    grid::rectGrob( # rect needs to be drawn first since default alpha is 1.
            gp = grid::gpar(
                col = "black", # adds black outline box to each key
                fill = scales::alpha(data$fill %||% data$colour %||% "grey20", data$alpha),
                lty = data$linetype %||% 1
        )
    ),
    grid::textGrob( # text needs to be drawn last so it is not overwritten by rect colors since default alpha is 1.
            data$label, 0.5, 0.5,
            hjust = 0.5, # horz center justified text
            vjust = 0.5, # vert center justified text
            rot = data$angle %||% 0,
            gp = grid::gpar(
                col = scales::alpha(data$colour %||% data$fill %||% "black", data$alpha),
                fontfamily = "Arial", # data$family %||% "", forces font to Arial
                fontface = data$fontface %||% 1,
                fontsize = 10, # (data$size %||% 3.88) * .pt, forces font size to 10 pt
                lineheight = 0.9
            )
        )
  ) # end of grid::grobTree()
}

font_family <- "Arial"
font_size <- 10

# new args for stackedBar_ggplot:
# df, font_size, font_family, new_fill_colors, key_width, key_height, label_colors_named, names(new_fill_colors_named)
new <- clean_items_single_div %>%
  ggplot2::ggplot(ggplot2::aes(
    x = .data[["percent_answers"]], y = forcats::fct_rev(.data[["question"]]), group = .data[["question"]]
  )) +
  ggplot2::geom_col(ggplot2::aes(fill = .data[["response"]]), 
    position = "fill", color = "black", # , show.legend = FALSE # turn off legend
    key_glyph = draw_key_cust #  ,width = 0.8 
  ) +
  ggplot2::geom_text(ggplot2::aes(label = .data[["percent_answers_label"]], color = .data[["label_color"]]),
    position = ggplot2::position_fill(vjust = 0.5),
    stat = "identity", size = font_size, size.unit = "pt", family = font_family
  ) +
  ggplot2::scale_color_identity() + # ----
  ggplot2::scale_fill_manual(values = new_fill_colors, labels = NULL) + # turn off labels in legend
  ggplot2::guides(fill = guide_legend(
    nrow = 1, keywidth = key_width, keyheight = key_height, # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
    override.aes = list(color = label_colors_named, # manually sets the color of the legend text to white or black
                        label = names(new_fill_colors_named)) # manually sets the legend labels to wrapped scale_labels
  )) +
  ggplot2::theme(
    text = ggplot2::element_text(
      angle = 0, hjust = 1, vjust = 0.5,
      family = font_family, size = font_size
    ),
    legend.position = "top",
    legend.title = element_blank(),
    legend.background = ggplot2::element_blank(),
    legend.box.spacing = grid::unit(0, "cm"), # no space btw legend and plot
    legend.key.spacing.x = grid::unit(0, "cm"), # no space btw legend key boxes
    axis.ticks = ggplot2::element_blank(),
    axis.title = ggplot2::element_blank(),
    axis.text = ggplot2::element_text(
      angle = 0, hjust = 1, vjust = 0.5,
      family = font_family, size = font_size
    ),
    axis.text.x = ggplot2::element_blank(), # turn off x axis labels
    axis.text.y = ggtext::element_markdown( # Controls the '.data[["question"]]' if pre_post is F, or 'timing' if Pre post labels
      color = "black", margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
    ),
    plot.background = ggplot2::element_blank(),
    panel.background = ggplot2::element_blank(),
    # Pre-post options:
    # panel.spacing = grid::unit(0, "cm"), # no space btw facet panels
    strip.background = ggplot2::element_blank(),
    strip.clip = "on",
    strip.placement = "outside",
    strip.switch.pad.wrap = grid::unit(0, "cm"),
    strip.text.y.left = ggtext::element_markdown( # Controls the .data[["question text on left- facet"]]
      color = "black",
      margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
    )
    # axis.text.y = ggtext::element_markdown( size = ggplot2::rel(0.8) # Controls the 'timing' Pre post labels
  )
new


```






