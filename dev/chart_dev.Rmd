---
title: "Chart Dev Work"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk[["set"]](echo = FALSE, 
    fig.width = 8,
    fig.height = 5)

# Load Libraries:
library(colorspace)
library(magrittr)
library(grid)
library(gridExtra)
library(tidyverse)
library(bre) # blackstone R package

set.seed(424429) # for reproducibility

##### colors:
breColors <- c("dark_blue" = "#283251",
                "light_grey" = "#eaeaeb",
                "med_grey" = "#cecece",
                "main_grey" = "#c0bfbf")


# light grey to BRE Blue color scale:
pal_bre_grey_blue <- colorRampPalette(c(breColors["light_grey"], breColors["dark_blue"]))
# pal_bre_grey_blue(length(scale_labels))
# 
# white to BRE Blue color scale:
pal_bre_blue <- colorRampPalette(c("white", breColors["dark_blue"]))
# pal_bre_grey_blue(length(scale_labels))

######## Data
items <- dplyr::tibble(
  pre_Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  post_Organization = dplyr::if_else(pre_Organization < 5, pre_Organization + 1, pre_Organization),
  pre_Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  post_Source = dplyr::if_else(pre_Source < 4, pre_Source + 2, pre_Source),
  pre_Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  post_Publish = pre_Publish + 2,
  pre_Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  post_Write = pre_Write + 1,
  pre_Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
  post_Research = pre_Research + 1
)

items_single <- dplyr::tibble(
  Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
)

# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_min_ext_named <- c(
  "Minimal" = "1", "Slight" = "2", "Moderate" = "3",
  "Good" = "4", "Extensive" = "5"
)

# levels_min_ext as just the names from levels_min_ext_named:
levels_min_ext <- names(levels_min_ext_named) 
# Question labels as a named vector with the naming structure
# like this: c("new label" = "original variable name"):
question_labels <- c(
  "Publish a lot of high quality papers" = "Publish",
  "Write a lot of research papers" = "Write",
  "Research in a lab with faculty" = "Research",
  "Organization of a large research project" = "Organization",
  "Source work for a research paper" = "Source"
)

# Recode the numeric to factor variables using the levels from levels_min_ext and Select the factor variables:
cat_items <- bre::recodeCat(items, levels_min_ext_named) %>% dplyr::select(dplyr::where(is.factor))
cat_items_single <- bre::recodeCat(items_single, levels_min_ext_named) %>% dplyr::select(dplyr::where(is.factor))


######## Data: Strongly disagree to Strongly Agree
items_single_div <- dplyr::tibble(
  Organization = c(1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 1),
  Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2, 6, 6, 6, 7, 7,7),
  Publish = c(1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4 , 5, 6, 7, 6),
  Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4, 5,6,7,1,2,3),
  Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4, 5,6,7,1,2,3),
)

items_div <- dplyr::tibble(
  pre_Organization = items_single_div[["Organization"]],
  post_Organization = dplyr::if_else(pre_Organization < 7, pre_Organization + 1, pre_Organization),
  pre_Source = items_single_div[["Source"]],
  post_Source = dplyr::if_else(pre_Source < 5, pre_Source + 2, pre_Source),
  pre_Publish = items_single_div[["Publish"]],
  post_Publish = dplyr::if_else(pre_Publish < 6, pre_Publish + 2, pre_Publish),
  pre_Write = items_single_div[["Write"]],
  post_Write = dplyr::if_else(pre_Write < 7, pre_Write + 1, pre_Write),
  pre_Research = items_single_div[["Research"]],
  post_Research = dplyr::if_else(pre_Research < 7, pre_Research + 1, pre_Research) 
)

# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_dis_agree_named <- c(
  "Strongly Disagree" = "1", "Somewhat Disagree" = "2", "Disagree" = "3",
  "Neither Agree or Disagree" = "4", "Agree" = "5", "Somewhat Agree" = "6", "Strongly Agree" = "7"
)

# levels_min_ext as just the names from levels_min_ext_named:
levels_dis_agree <- names(levels_dis_agree_named) 

# Recode the numeric to factor variables using the levels from levels_min_ext and Select the factor variables:
cat_items_div <- bre::recodeCat(items_div, levels_dis_agree_named) %>% dplyr::select(dplyr::where(is.factor))
cat_items_single_div <- bre::recodeCat(items_single_div, levels_dis_agree_named) %>% dplyr::select(dplyr::where(is.factor))

```

```{r}
# Function dev for gg_helpers.R file:

# Helper function to Add a Plot Tag, pass the total n, font size and family:
addPlotTag <- function(n, font_size, font_family) {
    list(
        ggplot2::labs(tag = paste0("(*n* = ", n , ")")),
        ggplot2::theme(plot.tag = ggtext::element_markdown(color = "black", size = font_size, family = font_family),
                       plot.tag.location = "panel", # places tag within panel
                       # plot.tag.position = "topleft"
                       plot.tag.position = c(-0.035, 1.04) # manually positions the tag using coordinates
                       )
    )
}

# addBarChartLegendTheme: sets the fill legend, and all theming for sb chart and div chart: args = font_size, font_family:
addBarChartLegendTheme <- function(font_size, font_family) {
    list(
        # ggplot2::guides(fill = ggplot2::guide_legend(nrow = 1
        #                                                  # override.aes = list(label = "  ", # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
        #                                                  #                     size = 4.5 # sets the size of legend key along with the two spaces in the previous line 
        #                                                  #                     )
        #                                                  )
            # ),
            ggplot2::theme_void(base_size = font_size, base_family = font_family),
            ggplot2::theme(legend.position = "top",
                           legend.direction = "horizontal",
                           # legend.key = element_rect(color = NA, fill = NA),
                           # legend.key.size = unit(0, "cm"),
                           legend.text.position = "right",
                           legend.text = ggplot2::element_text(angle = 0, hjust = 0, vjust = 0.55,
                                                               family = font_family
                                                               # size = rel(0.8)
                                                              ),
                           legend.box.spacing = unit(0, "cm"),
                           legend.ticks.length = rel(0),
                           legend.title = ggplot2::element_blank(),
                           axis.text = ggplot2::element_text(angle = 0, hjust = 1, vjust = 0.5,
                                                             family = font_family
                           ),
                           axis.text.x = ggplot2::element_blank(),
                           axis.text.y = ggtext::element_markdown( # Controls the 'question' if pre_post is F, or 'timing' if Pre post labels
                               angle = 0, hjust = 1, halign = 1, color = "black",
                               margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
                           ),
                           plot.margin = ggplot2::margin(t = 30, r = 5, b = 30, l = 5, unit = "pt"),
                           panel.spacing = grid::unit(0, "cm")
            )
    )
    
}

# addBarChartPrePostTheme: sets the fill legend, and all theming for sb chart and div chart: args = font_size, font_family:
addBarChartPrePostTheme <- function(font_size, font_family) {
        ggplot2::theme(strip.placement = "outside",
                       strip.switch.pad.wrap = grid::unit(0, "cm"),
                       strip.text.y.left = ggtext::element_markdown( # Controls the question text on left- facet
                           angle = 0, hjust = 1, color = "black", family = font_family, size = font_size,
                           margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
                       ),
                       axis.text.y = ggtext::element_markdown( size = rel(0.8) # Controls the 'timing' Pre post labels
                       )
                    )
    
}

```


### Update `bre::stackedBarChart()`

```{r}
# Start by processing the data using `bre::stackedBarChart()`:
clean_items_div <- dataVizCleaning(df = cat_items_div, scale_labels = levels_dis_agree, pre_post = T, na_remove = TRUE)

# Pull in all code from `stackBar_ggplot.R`:
# stackedBar_ggplot <- function(df_gg, x_gg , y_gg, fill_gg, group_gg, label_gg, label_color_gg, scale_labels_gg, width_gg, fill_colors_gg,
#                                   overall_n_gg, N_df_gg, pre_post = FALSE) {
# Set up arg inputs:                                 
df_gg = clean_items_div
x_gg = clean_items_div[["percent_answers"]]
# y_gg = clean_items_div[["question"]] # single
y_gg = clean_items_div[["timing"]] # pre_post
fill_gg = clean_items_div[["response"]]
group_gg = clean_items_div[["question"]]
scale_labels = levels_dis_agree
scale_labels_gg = scale_labels
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }

# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors` to map the text color to the variable response
clean_items_div <- clean_items_div %>% dplyr::mutate(., label_color = label_colors[clean_items_div[["response"]]])

label_gg = clean_items_div[["percent_answers_label"]]
label_color_gg = clean_items_div[["label_color"]]
width_gg = NULL
fill_colors_gg = new_fill_colors
overall_n_gg = T
# Get overall n if it is the same for each item:
totals_new_df <- clean_items_div %>%
        dplyr::group_by(.data$question) %>%
        dplyr::summarize(total = sum(.data$n_answers), .groups = "keep") %>%
        dplyr::ungroup()
# Get overall n if it is the same for each item:
        N_df <- totals_new_df %>%
          dplyr::summarize(N = mean(.data$total)) %>%
          tibble::deframe()
N_df_gg = N_df
pre_post = T

    # Load all fonts:
    extrafont::loadfonts("all", quiet = TRUE)

    # # Set . to NULL to stop message when using dot notation in mutate:
    # . <- NULL

    # Create a font family character var so that it is easy to change, could also be a new arg:
    font_family <- c("Arial")

    font_size <- 10

    stacked_bar_chart_gg <- {{df_gg}} %>%
        ggplot2::ggplot(ggplot2::aes(
            x = {{x_gg}}, y = forcats::fct_rev({{y_gg}}), group = {{group_gg}})) +
        ggplot2::geom_col(ggplot2::aes(fill = {{fill_gg}}), position = "fill", color = "black", width = {{width_gg}},
                          ) + # key_glyph = ggplot2::draw_key_label
        ggplot2::geom_text(ggplot2::aes(label = {{label_gg}}, color = {{label_color_gg}}), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = (font_size - 2), size.unit = "pt"
        ) +
        ggplot2::scale_color_identity()
    if (isTRUE(pre_post)) {
        stacked_bar_chart_gg <-  stacked_bar_chart_gg + ggplot2::facet_wrap(dplyr::vars({{ group_gg }}), ncol = 1, strip.position = "left")
    }
        stacked_bar_chart_gg <-  stacked_bar_chart_gg +
            ggplot2::scale_fill_manual(values = {{fill_colors_gg}}, drop = FALSE
                                       # labels = NULL,
                                       # guide = guide_legend(nrow = 1, override.aes = list(size = 2, shape = 21)
                                                            # )

            ) +
        addBarChartLegendTheme(font_size = font_size, font_family = font_family) + # function from `gg_helpers.R`
        ggplot2::guides(fill = NULL,
                        # fill = ggplot2::guide_legend(nrow = 1,
                        #           override.aes = list(label = stringr::str_wrap({{scale_labels_gg}}, width = 8), # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                        #           size = 2 # sets the size of legend key along with the two spaces in the previous line
                        #                                                      )
                        #                                  )
                        shape = ggplot2::guide_legend(nrow = 1,
                                  override.aes = list(label = stringr::str_wrap({{scale_labels_gg}}, width = 8), # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                                  size = 2 # sets the size of legend key along with the two spaces in the previous line
                                                                             )
                                                         )
                        ) +
      ggplot2::theme(legend.key.size = unit(1, "cm"),
                     legend.key.width = unit(1, "cm"), 
                     legend.key.height = unit(1, "cm")
        )

    if (isTRUE(pre_post)) {
        stacked_bar_chart_gg <- stacked_bar_chart_gg + addBarChartPrePostTheme(font_size = font_size, font_family = font_family) 
            # ggplot2::theme(strip.placement = "outside",
            #                strip.switch.pad.wrap = grid::unit(0, "cm"),
            #                strip.text.y.left = ggtext::element_markdown( # Controls the question text on left- facet
            #                    angle = 0, hjust = 1, color = "black", family = font_family, size = font_size,
            #                    margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
            #                ),
            #                axis.text.y = ggtext::element_markdown( size = rel(0.8) # Controls the 'timing' Pre post labels
            #                )
            # )
    }

    # Set tag to N_df if overall_n_gg == TRUE
    if (isTRUE(overall_n_gg)) {
        stacked_bar_chart_gg <- stacked_bar_chart_gg + addPlotTag(n = N_df_gg, font_size = font_size, font_family = font_family)
        # addPlotTag() Replaces code below: 
        # stacked_bar_chart_gg <- stacked_bar_chart_gg + ggplot2::labs(tag = paste0("(*n* = ",  N_df_gg , ")")) +
        #                                                ggplot2::theme(plot.tag = ggtext::element_markdown(color = "black", size = font_size, family = font_family),
        #                                                               plot.tag.location = "panel", # places tag within panel
        #                                                               # plot.tag.position = "topleft"
        #                                                               plot.tag.position = c(-0.035, 1.04) # manually positions the tag using coordinates
        #                                                               )
    } else {
        # stacked_bar_chart_gg <- stacked_bar_chart_gg + ggplot2::labs(title = NULL, x = NULL, tag = NULL)
    }
stacked_bar_chart_gg

```



```{r}
# Start by processing the data using `bre::stackedBarChart()`:
clean_items_single_div <- dataVizCleaning(df = cat_items_single_div, scale_labels = levels_dis_agree, pre_post = F, na_remove = TRUE)
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors` to map the text color to the variable response
clean_items_single_div <- clean_items_single_div %>% dplyr::mutate(., label_color = label_colors[clean_items_single_div[["response"]]])

```

```{r}
#  `new_fill_colors` as a named vector combined with `scale_labels`, where the names are the labels and values are the colors from `new_fill_colors`:
new_fill_colors_named <- new_fill_colors
names(new_fill_colors_named) <- stringr::str_wrap(scale_labels, width = 8)
# function to build all grobs:
# map(.x = seq_along(new_fill_colors_named), \(.x)
# list(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[.x]), x = (0 + (.x/10)), y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
#      textGrob(label = names(new_fill_colors_named)[.x], x = (0 + (.x/10)), y = 1, hjust = 0, gp = gp)
#      )
# )
grid::grid.newpage()
## These *do* nothing but produce a "gpar" object:
gp <- gpar(col = "black", fontsize = 10, fontfamily = "Arial")
vp <- viewport(width = .8, height = .4)
g <- gTree(children = gList(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[1]),x = 0, y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
                            textGrob(label = names(new_fill_colors_named)[1], x = 0.03, y = 1, hjust = 0, gp = gp),
                            rectGrob(gp = gpar(col = new_fill_colors_named[2]),x = 0.3, y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm"))
                            ), gp = gp, vp = vp)
grid.draw(g)
## example with multiple values for a parameter
pushViewport(viewport())
popViewport()

```

```{r}
grid.newpage()
gp <- gpar(col = "black", fontsize = 10, fontfamily = "Arial")
vp <- viewport(width = .8, height = .4)
grob_list <- map(.x = seq_along(new_fill_colors_named), \(.x)
                    gList(rectGrob(gp = gpar(col = "black", lwd = 1.2, fill = new_fill_colors_named[.x]), x = (0 + (.x/7.5)), y = 1, width = unit(0.6, "cm"), height = unit(0.6, "cm")),
                          textGrob(label = names(new_fill_colors_named)[.x], x = (0.03 + (.x/7.5)), y = 1, hjust = 0, check.overlap = TRUE, gp = gp)
                          )
                    )
g <- grobTree(children = do.call(grid::gList, grob_list), gp = gp, vp = vp)

# gridExtra::grid.arrange(grobs = grob_list)
# g <- gTree(children = grob_list[[7]], gp = gp, vp = vp)
grid.draw(g)
## example with multiple values for a parameter
pushViewport(viewport())
popViewport()

# is.grob(g)
```



```{r}
## Data:
  n <- 10
  x <- stats::runif(n) ; y1 <- stats::runif(n) ; y2 <- stats::runif(n)
  ## Construct the grobs :
  plot <- gTree(children=gList(rectGrob(),
                  pointsGrob(x, y1, pch=21, gp=gpar(col=2, fill=2)),
                  pointsGrob(x, y2, pch=22, gp=gpar(col=3, fill=3)),
                  xaxisGrob(),
                  yaxisGrob()))
  legd <- grid::legendGrob(names(new_fill_colors_named), nrow = 1, pch = 22, # pch 22 is a filled square
                     hgap = grid::unit(0.2, "cm"), # horz spacing btw legends
                     gp = grid::gpar(col = "black", fontsize = 10, fontfamily = "Arial",
                                     fill = new_fill_colors_named)) # gp fill is the color to fill 
  gg <- packGrob(packGrob(frameGrob(), plot),
                 legd, height=unit(1,"null"), side="top")

  ## Now draw it on a new device page:
  grid.newpage()
  pushViewport(viewport(width=0.8, height=0.8))
  grid.draw(gg)
```

```{r}
legendGrobCustom <-
    function(labels, nrow, ncol, byrow=FALSE,
	     do.lines = has.lty || has.lwd, lines.first=TRUE,
	     hgap=unit(1, "lines"), vgap=unit(1, "lines"),
	     default.units="lines",
	     pch, sym_size = unit(1, "char"), 
	     gp =gpar(), vp=NULL)
{
    ## Type checking on arguments; labels: character, symbol or expression:
    labels <- as.graphicsAnnot(labels)
    labels <- if(is.character(labels)) as.list(labels) else as.expression(labels)
    nkeys <- if(is.call(labels)) 1 else length(labels)
    if(nkeys == 0) return(nullGrob(vp=vp))
    if (!is.unit(hgap))
	hgap <- unit(hgap, default.units)
    if (length(hgap) != 1) stop("'hgap' must be single unit")
    if (!is.unit(vgap))
	vgap <- unit(vgap, default.units)
    if (length(vgap) != 1) stop("'vgap' must be single unit")
    ## nrow, ncol
    miss.nrow <- missing(nrow)
    miss.ncol <- missing(ncol)
    if(miss.nrow && miss.ncol) {ncol <- 1; nrow <- nkeys} # defaults to 1-column legend
    else if( miss.nrow && !miss.ncol) nrow <- ceiling(nkeys / ncol)
    else if(!miss.nrow &&  miss.ncol) ncol <- ceiling(nkeys / nrow)
    if(nrow < 1) stop("'nrow' must be >= 1")
    if(ncol < 1) stop("'ncol' must be >= 1")
    if(nrow * ncol < nkeys)
        stop("nrow * ncol < #{legend labels}")
    ## pch, gp
    if(has.pch <- !missing(pch) && length(pch) > 0) pch <- rep_len(pch, nkeys)
    if(doGP <- length(nmgp <- names(gp)) > 0) {
	if(has.lty  <-  "lty" %in% nmgp) gp$lty  <- rep_len(gp$lty, nkeys)
	if(has.lwd  <-  "lwd" %in% nmgp) gp$lwd  <- rep_len(gp$lwd, nkeys)
	if(has.col  <-  "col" %in% nmgp) gp$col  <- rep_len(gp$col,  nkeys)
	if(has.fill <- "fill" %in% nmgp) gp$fill <- rep_len(gp$fill, nkeys)
    } else {
	gpi <- gp
	if(missing(do.lines)) do.lines <- FALSE
    }

    ## main
    u0 <- unit(0, "npc")
    u1 <- unit(1, "char")
    ord <- if(lines.first) 1:2 else 2:1
    fg <- frameGrob(vp = vp)	  # set up basic frame grob (for packing)
    for (i in seq_len(nkeys)) {
	if(doGP) {
	    gpi <- gp
	    if(has.lty)	 gpi$lty <- gp$lty[i]
	    if(has.lwd)	 gpi$lwd <- gp$lwd[i]
	    if(has.col)	 gpi$col <- gp$col[i]
	    if(has.fill) gpi$fill <- gp$fill[i]
	}
	if(byrow) {
	    ci <- 1+ (i-1) %%  ncol
	    ri <- 1+ (i-1) %/% ncol
	} else {
	    ci <- 1+ (i-1) %/% nrow
	    ri <- 1+ (i-1) %%  nrow
	}
	## borders; unit.c creates a 4-vector of borders (bottom, left, top, right)
	vg <- if(ri != nrow) vgap else u0
	symbol.border <- unit.c(vg, u0, u0, 0.5 * hgap)
	text.border   <- unit.c(vg, u0, u0, if(ci != ncol) hgap else u0)

	## points/lines grob:
	plGrob <- if(has.pch && do.lines)
	    gTree(children = gList(linesGrob(c(sym_size:1, sym_size:1 + 0.5), 0.5, gp=gpi),
		  pointsGrob(0.5, 0.5, default.units="npc", pch=pch[i], gp=gpi, size = sym_size))[ord])
	else if(has.pch) pointsGrob(0.5, 0.5, default.units="npc", pch=pch[i], gp=gpi, size = sym_size)
	else if(do.lines) linesGrob(c(sym_size:1, sym_size:1 + 0.5), 0.5, gp=gpi)
	else nullGrob() # should not happen...
	fg <- packGrob(fg, plGrob,
		       col = 2*ci-1, row = ri, border = symbol.border,
		       width = u1, height = u1, force.width = TRUE)
	## text grob: add the labels
	gpi. <- gpi
	gpi.$col <- "black" # maybe needs its own 'gp' in the long run (?)
	fg <- packGrob(fg, textGrob(labels[[i]], x = 0, y = 0.5,
				    just = c("left", "centre"), gp=gpi.),
		       col = 2*ci, row = ri, border = text.border)
    }
    fg
}

```

```{r}
font_family <- "Arial"
font_size <- 10


new <- clean_items_single_div %>%
        ggplot2::ggplot(ggplot2::aes(
            x = percent_answers, y = forcats::fct_rev(question), group = question)) +
        ggplot2::geom_col(ggplot2::aes(fill = response), position = "fill", color = "black", show.legend = FALSE # turn off legend
                          ) + # key_glyph = ggplot2::draw_key_label
        ggplot2::geom_text(ggplot2::aes(label = percent_answers_label, color = label_color), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = font_size, size.unit = "pt", 
        ) +
    ggplot2::scale_color_identity() +
    ggplot2::scale_fill_manual(values = new_fill_colors, labels = ~ stringr::str_wrap(., width = 8)) +
    ggplot2::guides(custom = ggplot2::guide_custom(grob = legendGrobCustom(names(new_fill_colors_named), # using scale_labels and one row or ncol= 1,
                                                                           nrow = 1, # using scale_labels and one row
                                                                           # do.lines = TRUE,
                                                                           pch = 22, # pch 22 is a filled square
                                                                           sym_size = grid::unit(0.65, "cm"), # new size par for sizing pch symbol 
                                                                           hgap = grid::unit(0.3, "cm"), # horz spacing btw legends
                                                                           gp = grid::gpar(col = "black", fontsize = (font_size - 1), fontfamily = font_family,
                                                                                           lineheight = 0.9,
                                                                                           fill = new_fill_colors),# gp fill is the color to fill
                                                                           )
                                                   )
                    ) +
    ggplot2::theme(legend.position = "top",
                   legend.box.spacing = grid::unit(0, "cm"),
                   axis.ticks = ggplot2::element_blank(),
                   axis.title = ggplot2::element_blank(),
                   axis.text = ggplot2::element_text(angle = 0, hjust = 1, vjust = 0.5,
                                                             family = font_family
                           ),
                   axis.text.x.bottom = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.text.y = ggtext::element_markdown( # Controls the 'question' if pre_post is F, or 'timing' if Pre post labels
                       angle = 0, hjust = 1, halign = 1, color = "black",
                       margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
                   ),
                   plot.background = ggplot2::element_blank(),
                   panel.background = ggplot2::element_blank(),
                   legend.background = ggplot2::element_blank()
                   )

new  


```


```{r}
dat <- data.frame(x = seq(1,100,by=2), y = seq(1,300,by=3))

df <- data.frame(class = c("very high", "high", "medium", "low", "very low"),
            lwr = c(90, 75, 35, 15, 0),
            upr = c(100, 90, 75, 35, 15))


# Color palette
pal <- scales::viridis_pal(option = "viridis")(5)
names(pal) <- c("very high", "high", "medium", "low", "very low")

# Legend key labels
key_label <- df |>
  mutate(key_label = case_when(
    upr == 100 ~ paste(">", lwr),
    lwr == 0 ~ paste("<", upr),
    TRUE ~ paste(lwr, upr, sep = "-")
  )) |>
  select(class, key_label) |>
  tibble::deframe()

# Legend key width = maximum label * 1.10 to add some padding
width <- unit(max(sapply(key_label, strwidth, units = "inches")) * 1.10, "in")

# Custom key glyph
draw_key_cust <- function(data, params, size) {
  data_text <- data
  data_text$label <- key_label[names(pal)[match(data$fill, pal)]]
  data_text[c("fill")] <- NULL
  data_text$colour <- "black"
  data_text$alpha <- 1
  data_text$size <- 11 / .pt

  grid::grobTree(
    draw_key_rect(data, list()),
    draw_key_text(data_text, list())
  )
}

ggplot(dat) +
  geom_rect(data = df, aes(xmin = lwr, xmax = upr, ymin = -Inf, ymax = Inf, fill = class), alpha = 0.4, key_glyph = draw_key_cust) +
  geom_point(aes(x, y)) +
  scale_fill_manual("Classes", values = pal, limits = c("very high", "high", "medium", "low", "very low")) +
  guides(fill = guide_legend(keywidth = width, keyheight = unit(.3, "in"))) + # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
  theme_bw() + 
  ggplot2::theme(legend.position = "top")
```


```{r}

# Start by processing the data using `bre::stackedBarChart()`:
clean_items_single_div <- dataVizCleaning(df = cat_items_single_div, scale_labels = levels_dis_agree, pre_post = F, na_remove = TRUE)
fill_colors = "div"
# If statement to handle the value(s) of `fill_colors`:
    if (length(fill_colors) > 1) {
        if (length(fill_colors) >= length(scale_labels)) {
            new_fill_colors <- fill_colors # sets the fill colors to the hex codes passed in by the user.
        } else {
            stop("Error: the length of `fill_colors` needs to be greater than or equal to the length of `scale_labels.`")
        }
    } else if (fill_colors == "seq") {
        new_fill_colors <- seqFillColors(length(scale_labels)) # sets the fill colors to the default sequential palette of `cividis`.
    } else if (fill_colors == "div") {
        new_fill_colors <- divFillColors(length(scale_labels)) # sets the fill colors to the default diverging palette of `Blue Red 3` from namespace `colorspace`.
    }
# Use the internal function labelColorMaker(), to create text color labels of black or white, see `helpers.R`:
label_colors <- labelColorMaker(new_fill_colors, names = scale_labels)
# create a new col `label_color` using the named vector `label_colors` to map the text color to the variable response
clean_items_single_div <- clean_items_single_div %>% dplyr::mutate(., label_color = label_colors[clean_items_single_div[["response"]]])

# Color palette named by the scale_labels:
new_fill_colors_named <- new_fill_colors # palette as values
names(new_fill_colors_named) <- str_wrap(scale_labels, width = 10) # names as str_wrap scale_labels

# Legend key width = maximum label strwidth: PASS TO guide_legend keywidth
key_width <- unit(max(sapply(names(new_fill_colors_named), strwidth, units = "inches")) * 0.8, "in")
# Legend key height = maximum label strheight: PASS TO guide_legend keyheight
key_height <- unit(max(sapply(names(new_fill_colors_named), strheight, units = "inches")) * 0.8, "in")

# Custom draw_key_rect, adds black outline box
draw_key_rect_cust <- function(data, params, size) {
  grid::rectGrob(gp = grid::gpar(
    col = "black", # adds black outline box to each key
    fill = scales::alpha(data$fill %||% data$colour %||% "grey20", data$alpha),
    lty = data$linetype %||% 1
  ))
}
# Custom draw_key_text, adds just and lineheight:
draw_key_text_cust <- function(data, params, size) {
  if (is.null(data$label)) data$label <- "a"
  grid::textGrob(data$label, 0.5, 0.5,
            hjust = 0.5, # left justified text
            vjust = 0.5,
            rot = data$angle %||% 0,
            gp = grid::gpar(
              col = scales::alpha(data$colour %||% data$fill %||% "black", data$alpha),
              fontfamily = data$family %||% "",
              fontface = data$fontface %||% 1,
              fontsize = (data$size %||% 3.88) * .pt,
              lineheight = 0.9
            )
        )
}

# Custom key glyph
draw_key_cust <- function(data, params, size) {
  data_text <- data
  data_text$label <- names(new_fill_colors_named)[match(data$fill, new_fill_colors_named)] # match the scale_labels to the new pal in new_fill_colors_named
  data_text[c("fill")] <- NULL
  data_text$alpha <- 1
  data_text$size <- 8/.pt

  grid::grobTree(
    draw_key_rect_cust(data, list()),
    draw_key_text_cust(data_text, list())
  )
}

font_family <- "Arial"
font_size <- 10


new <- clean_items_single_div %>%
        ggplot2::ggplot(ggplot2::aes(
            x = percent_answers, y = forcats::fct_rev(question), group = question)) +
        ggplot2::geom_col(ggplot2::aes(fill = response), position = "fill", color = "black", # , show.legend = FALSE # turn off legend
                          key_glyph = draw_key_cust) + # key_glyph = ggplot2::draw_key_label
        ggplot2::geom_text(ggplot2::aes(label = percent_answers_label, color = label_color), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = font_size, size.unit = "pt"
        ) +
    ggplot2::scale_color_identity() +
    ggplot2::scale_fill_manual(values = new_fill_colors, labels = NULL) +
    ggplot2::guides(fill = guide_legend(nrow = 1, keywidth = key_width, keyheight = key_height, # keywidth and keyheight need to be supplied as a grid::unit() to change size of keys!!!!!!
                                        override.aes = list(color = labelColorMaker(new_fill_colors, names = scale_labels)), # sets the color of the legend text to white or black
                                        theme = ggplot2::theme(legend.spacing.x = unit(2, 'cm'))
                                        )
                                    ) + 
    ggplot2::theme(legend.position = "top",
                   legend.title = element_blank(),
                   legend.box.spacing = grid::unit(0, "cm"), # no space btw legend and plot
                   axis.ticks = ggplot2::element_blank(),
                   axis.title = ggplot2::element_blank(),
                   axis.text = ggplot2::element_text(angle = 0, hjust = 1, vjust = 0.5,
                                                             family = font_family
                           ),
                   axis.text.x.bottom = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.text.y = ggtext::element_markdown( # Controls the 'question' if pre_post is F, or 'timing' if Pre post labels
                       angle = 0, hjust = 1, halign = 1, color = "black",
                       margin = ggplot2::margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
                   ),
                   plot.background = ggplot2::element_blank(),
                   panel.background = ggplot2::element_blank(),
                   legend.background = ggplot2::element_blank()
                   )

new  


```



```{r}
library(ggplot2)
library(gtable)
library(grid)
library(dplyr)
library(forcats)

# Your starting data and plot code
stacked_bar_chart_gg <- {{df_gg}} %>%
  ggplot(ggplot2::aes(
    x = {{x_gg}}, y = forcats::fct_rev({{y_gg}}), group = {{group_gg}}, fill = {{fill_gg}}
  )) +
  geom_col(position = "fill", color = "black", width = {{width_gg}}, key_glyph = draw_key_label) + # , key_glyph = draw_key_rect
   ggplot2::geom_text(ggplot2::aes(label = {{label_gg}}, color = {{label_color_gg}}), position = ggplot2::position_fill(vjust = 0.5),
                           stat = "identity", size = font_size, size.unit = "pt"
        ) +
  scale_color_identity() +
  scale_fill_manual(
    breaks = {{scale_labels_gg}}, values = {{fill_colors_gg}}, drop = FALSE,
    labels = str_wrap({{scale_labels_gg}}, width = 8)
  ) +
  guides(
    fill = guide_legend(
      nrow = 1,
      override.aes = list(label = "  ", # sets the width of `key_glyph = draw_key_label` in geom_col for the legend.
                          size = 5 # sets the size of legend key along with the two spaces in the previous line 
                          )
    )
  ) +
  theme_void(base_family = font_family, base_size = font_size) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal",
    legend.text.position = "right",
    legend.text = element_text(
      angle = 0, hjust = 0, vjust = 0.5,
      family = font_family, size = rel(0.8)
    ),
    legend.title = element_blank(),
    axis.text = element_text(
      angle = 0, hjust = 1, vjust = 0.5,
      family = font_family
    ),
    axis.text.x = element_blank(),
    axis.text.y = ggtext::element_markdown(
      angle = 0, hjust = 1, halign = 1, color = "black",
      margin = margin(t = 5, r = -15, b = 5, l = 5, unit = "pt")
    ),
    plot.margin = margin(t = 30, r = 5, b = 30, l = 5, unit = "pt"),
    panel.spacing = unit(0, "cm")
  )

stacked_bar_chart_gg

# Extract the ggplot grob
# g <- ggplotGrob(stacked_bar_chart_gg)
# grid::grid.draw(g) 
# # Adjust legend key sizes
# g$grobs <- lapply(g$grobs, function(x) {
#   if(x$name == "gtable[guide-box]") {
#     x$grobs[[1]]$grobs[[1]]$heights <- unit(rep(0.01, length(x$grobs[[1]]$grobs[[1]]$heights)), "cm")
#     x$grobs[[1]]$grobs[[1]]$widths <- unit(rep(2, length(x$grobs[[1]]$grobs[[1]]$widths)), "cm")
#   }
#   return(x)
# })
# 
# 
# ggpubr::as_ggplot(g)

```




