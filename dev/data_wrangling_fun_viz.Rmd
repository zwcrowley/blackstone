---
title: "Data Wrangling Function for `bre`"
output: html_document
date: "2024-05-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
    fig.width = 8,
    fig.height = 6)

# Load Libraries:
library(magrittr)
library(tidyverse)

######### Data
items <- dplyr::tibble(
  pre_Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  post_Organization = dplyr::if_else(pre_Organization < 5, pre_Organization + 1, pre_Organization),
  pre_Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  post_Source = dplyr::if_else(pre_Source < 4, pre_Source + 2, pre_Source),
  pre_Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  post_Publish = pre_Publish + 2,
  pre_Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  post_Write = pre_Write + 1,
  pre_Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
  post_Research = pre_Research + 1
)

items_single <- dplyr::tibble(
  Organization = c(1, 2, 3, 4, 5, 4, 3, 2, 1),
  Source = c(2, 2, 3, 5, 4, 3, 2, 1, 2),
  Publish = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  Write = c(2, 2, 2, 3, 3, 3, 4, 4, 4),
  Research = c(1, 1, 2, 2, 3, 3, 4, 4, 4),
)

# Set scale_labels for recodeCat function:
# scale_labels as a named character vector, items in correct order:
levels_min_ext_named <- c(
  "Minimal" = "1", "Slight" = "2", "Moderate" = "3",
  "Good" = "4", "Extensive" = "5"
)

# bar_scale_labels as just the names from levels_min_ext:
bar_scale_labels <- names(levels_min_ext_named)

levels_min_ext <- names(levels_min_ext_named) 
# Question labels as a named vector with the naming structure
# like this: c("new label" = "original variable name"):
question_labels <- c(
  "Publish a lot of high quality papers" = "Publish",
  "Write a lot of research papers" = "Write",
  "Research in a lab with faculty" = "Research",
  "Organization of a large research project" = "Organization",
  "Source work for a research paper" = "Source"
)

# Recode the numeric to factor variables using the levels from levels_min_ext:
cat_items <- bre::recodeCat(items, levels_min_ext_named)
cat_items_single <- bre::recodeCat(items_single, levels_min_ext_named)

# Select the factor variables:
items_pre_post <- cat_items %>% dplyr::select(dplyr::where(is.factor)) %>% select(contains(c("pre_", "post_")))
# %>% rename_with(~ paste0("pre_",stringr::str_replace(.,"_pre","")), .cols = contains("pre")) 
items_single <- cat_items_single %>% dplyr::select(dplyr::where(is.factor)) %>% select(!contains(c("pre_", "post_")))

# 

```


```{r}
# ARGS:
new_df <- items_pre_post
scale_labels <- levels_min_ext
na_remove <- TRUE # if true remove NA, if FALSE convert to character and make the lowest factor:

# For pre-post data:
# Test if all vars contain c("pre_", "post_"), if not then stop and return an error message:
test_names <- new_df %>% names() %>% str_detect(., paste(c("pre_", "post_"), collapse = "|"))
if (any(test_names == FALSE)) {
    stop("the variables do not have `pre_` and/or `post_` prefixes, makes sure all variables have the correct prefixes.")
}
# new_df %>% select(contains(c("pre_", "post_"))) %>% names() 
# test_names <- new_df %>% names() %>% str_detect(., paste(c("pre_", "post_"), collapse = "|"))
# any(test_names == FALSE)
# test_names <- append(test_names, FALSE) 
# all(test_names == TRUE)


# Sets up new_df:
    new_df <- new_df %>%
      tidyr::pivot_longer(contains(c("pre_", "post_")), names_to = "question", values_to = "response") %>%
      dplyr::mutate(question = stringr::str_remove(.data$question, "cat_")) %>%
      tidyr::separate(.data$question, into = c("timing", "question"), sep = "_", extra = "merge") %>%
      dplyr::mutate(response = factor(.data$response, levels = scale_labels)) %>%
      dplyr::group_by(.data$question, .data$timing, .data$response) %>%
      dplyr::summarize(n_answers = dplyr::n(), .groups = "keep") %>%
      dplyr::ungroup() %>%
      tidyr::drop_na() %>% 
      dplyr::group_by(.data$question, .data$timing) %>%
      dplyr::mutate(
        percent_answers = .data$n_answers / sum(.data$n_answers),
        timing = stringr::str_to_title(.data$timing), # capitalize timing
        timing = factor(.data$timing, levels = c("Pre", "Post"))
      ) %>%
      dplyr::ungroup()
    
    new_df
```

```{r}
new_df <- items_pre_post
scale_labels <- levels_min_ext
na_remove <- TRUE # if true remove NA, if FALSE convert to character and make the lowest factor:

# Start writing new function, name it dataVizCleaning() or something better, 4 args: df, pre_post, scale_labels, na_remove,:
dataVizCleaning <- function(df, pre_post = TRUE, scale_labels, na_remove = TRUE) {
    
    if (isTRUE(na_remove)) {
        
    
        if (isTRUE(pre_post)) {
    
            # For pre-post data:
            # Test if all vars contain c("pre_", "post_"), if not then stop and return an error message:
            test_names <- new_df %>% names() %>% str_detect(., paste(c("pre_", "post_"), collapse = "|"))
            if (any(test_names == FALSE)) {
                stop("the variables do not have `pre_` and/or `post_` prefixes, makes sure all variables have the correct prefixes.")
            }
    
            # Sets up new_df:
                new_df <- new_df %>%
                  tidyr::pivot_longer(contains(c("pre_", "post_")), names_to = "question", values_to = "response") %>%
                  dplyr::mutate(question = stringr::str_remove(.data$question, "cat_")) %>%
                  tidyr::separate(.data$question, into = c("timing", "question"), sep = "_", extra = "merge") %>%
                  dplyr::mutate(response = factor(.data$response, levels = scale_labels)) %>%
                  dplyr::group_by(.data$question, .data$timing, .data$response) %>%
                  dplyr::summarize(n_answers = dplyr::n(), .groups = "keep") %>%
                  dplyr::ungroup() %>%
                  tidyr::drop_na() %>% 
                  dplyr::group_by(.data$question, .data$timing) %>%
                  dplyr::mutate(
                    percent_answers = .data$n_answers / sum(.data$n_answers),
                    timing = stringr::str_to_title(.data$timing), # capitalize timing
                    timing = factor(.data$timing, levels = c("Pre", "Post"))
                  ) %>%
                  dplyr::ungroup()
        } # end of if pre_post == TRUE
    
    } # end of if na_remove == TRUE
            
            return(new_df)
}
```

